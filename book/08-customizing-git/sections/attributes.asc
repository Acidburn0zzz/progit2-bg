=== Git атрибути

(((attributes)))
Някои от настройките на Git може да се прилагат към конкретен път, така че да важат за определена поддиректория или набор от файлове.
Този вид настройки се наричат Git атрибути и се задават или във файл с име `.gitattributes` в една от директориите (основно главната) или във файла `.git/info/attributes`.

Използвайки атрибути можете да правите неща като например отделни стратегии за сливане за индивидуални файлове или директории в проекта, да указвате на Git как да прави diff на файлове, които не са текстови, или да накарате Git да филтрира съдържание преди да ви го извлече или запише.
Тук ще разгледаме малко примери за използване на атрибути.

==== Двоични файлове

(((binary files)))
Един хубав трик, който можете да приложите, е да кажете на Git кои файлове са двоични (в случай, че по някаква причина не се разпознават като такива) и да подадете специални инструкции за тяхната обработка.
Например, някои текстови файлове може да са машинно генерирани и да не може да им се направи diff, докато за някои други двоични файлове това е възможно.
Ето как да кажете на Git кой какъв е.

===== Идентифициране на двоични файлове

Some files look like text files but for all intents and purposes are to be treated as binary data.
Някои файлове изглеждат като текстови, но данните в тях се третират като двоични.
Например, Xcode проктите в Mac съдържат файл с окончание `.pbxproj`, който всъщност е JSON (текстов формат за структуриране на данни) информация записана на диска от IDE средата и съхранява настройки за компилиране и други данни.
Въпреки, че технически това е текстов файл (изцяло UTF-8), не искате да го третирате като такъв, понеже той играе ролята на олекотена база данни -- не можете да слеете модификациите, ако двама души го променят и в общи линни diff информацията не е особено полезна.
Файлът просто е предназначен да се обработва от машината.
Реално, искате да го третирате като двоичен.

За да кажете на Git, че искате да третира всички `pbxproj` файлове като двоични, добавете това във вашия `.gitattributes` файл:

[source,ini]
----
*.pbxproj binary
----

Сега Git няма да се опитва да конвертира или коригира CRLF проблеми, нито ще се опитва да изчислява или печата diff за промените в такива файлове при изпълнение на `git show` или `git diff`.

===== Diff за двоични файлове

Можете обаче да накарате Git да прави diff на двоични файлове.
Това става, като указвате на системата да конвертира двоичната информация в текст, който да се съпоставя с нормална diff операция.

Ще използваме тази техника за решаване на един от най-досадните известни проблеми: контрол на версиите за Microsoft Word документи.
За мнозина Word е един от най-ужасните редактори, обаче парадоксално продължава да се ползва масово.
Ако искате да контролирате Word документи, можете да ги съберете в Git хранилище и да къмитвате от време на време, но каква полза получавате с това?
Ако нормално изпълните `git diff`, виждате нещо такова:

[source,console]
----
$ git diff
diff --git a/chapter1.docx b/chapter1.docx
index 88839c4..4afcb7c 100644
Binary files a/chapter1.docx and b/chapter1.docx differ
----

Не можете директно да съпоставите две версии, докато не ги извлечете и разгледате на ръка.
Оказва се, че можете да правите това добре с Git атрибути.
Сложете следния ред в `.gitattributes` файла:

[source,ini]
----
*.docx diff=word
----

Това указва на Git, че ако файлът отговаря на тази маска(`.docx`), то той трябва да използва филтъра  ``word'', при опит за конструиране на diff.
Какво е ``word'' филтър?
Ще трябва да го настроите.
В случая, ще използваме програмата `docx2txt` за да конвертираме Word документите в четими текстови файлове, за които могат да се правят четими diff-ове.

Първо инсталираме `docx2txt`; налична е на http://docx2txt.sourceforge.net[].
Следваме инструкциите в `INSTALL` файла за да я сложим на място, в което шелът да я намира.
След това, ще напишем кратък wrapper скрипт за конвертиране на изхода във формат, който Git очаква.
Създайте файл достъпен в пътя ви с име `docx2txt`, съдържащ:

[source,console]
----
#!/bin/bash
docx2txt.pl "$1" -
----

След това изпълнете `chmod a+x` за него.
Последно, конфигурираме Git да използва скрипта:

[source,console]
----
$ git config diff.word.textconv docx2txt
----

Сега Git знае, че ако се опитва да направи diff между два snapshot-а и някой от файловете е с окончание `.docx`, той трябва да го прекара през ``word'' филтъра, дефиниран като `docx2txt` програмата. 
Това на практика произвежда текстови версии на Word документите преди да опита да ги съпостави за diff.

Ето пример: Глава 1 от таиз книга е конвертирана в Word формат и къмитната в Git хранилище.
След това е добавен нов параграф.
Ето изхода от `git diff`:

[source,console]
----
$ git diff
diff --git a/chapter1.docx b/chapter1.docx
index 0b013ca..ba25db5 100644
--- a/chapter1.docx
+++ b/chapter1.docx
@@ -2,6 +2,7 @@
 This chapter will be about getting started with Git. We will begin at the beginning by explaining some background on version control tools, then move on to how to get Git running on your system and finally how to get it setup to start working with. At the end of this chapter you should understand why Git is around, why you should use it and you should be all setup to do so.
 1.1. About Version Control
 What is "version control", and why should you care? Version control is a system that records changes to a file or set of files over time so that you can recall specific versions later. For the examples in this book you will use software source code as the files being version controlled, though in reality you can do this with nearly any type of file on a computer.
+Testing: 1, 2, 3.
 If you are a graphic or web designer and want to keep every version of an image or layout (which you would most certainly want to), a Version Control System (VCS) is a very wise thing to use. It allows you to revert files back to a previous state, revert the entire project back to a previous state, compare changes over time, see who last modified something that might be causing a problem, who introduced an issue and when, and more. Using a VCS also generally means that if you screw things up or lose files, you can easily recover. In addition, you get all this for very little overhead.
 1.1.1. Local Version Control Systems
 Many people's version-control method of choice is to copy files into another directory (perhaps a time-stamped directory, if they're clever). This approach is very common because it is so simple, but it is also incredibly error prone. It is easy to forget which directory you're in and accidentally write to the wrong file or copy over files you don't mean to.
----

Git успешно забелязва промяната и сбито ни казва, че сме добавили стринга ``Testing: 1, 2, 3.''. 
Разбира се, това не е перфектно -- промените по форматирането няма да се покажат.

Друг интересен проблем е съпоставянето на файлове с изображения.
Един начин да правите това е да прекарате изображение през филтър, който извлича EXIF информацията им -- това са метаданни съхранявани с повечето формати за изображения.
Ако изтеглите и инсталирате програмата `exiftool`, може да я ползвате за да извличате метаданните, така че diff поне ще ви покаже в текстов вид направените промени.
Сложете реда отдолу в `.gitattributes` файла:

[source,ini]
----
*.png diff=exif
----

Настройте Git да използва инструмента:

[source,console]
----
$ git config diff.exif.textconv exiftool
----

Ако замените изображение в проекта и изпълните `git diff`, виждате нешо подобно:

[source,diff]
----
diff --git a/image.png b/image.png
index 88839c4..4afcb7c 100644
--- a/image.png
+++ b/image.png
@@ -1,12 +1,12 @@
 ExifTool Version Number         : 7.74
-File Size                       : 70 kB
-File Modification Date/Time     : 2009:04:21 07:02:45-07:00
+File Size                       : 94 kB
+File Modification Date/Time     : 2009:04:21 07:02:43-07:00
 File Type                       : PNG
 MIME Type                       : image/png
-Image Width                     : 1058
-Image Height                    : 889
+Image Width                     : 1056
+Image Height                    : 827
 Bit Depth                       : 8
 Color Type                      : RGB with Alpha
----

Така поне можем да видим, че са променени размерите на изображението и големината на файла.

[[_keyword_expansion]]
==== Попълване на ключови думи

(((keyword expansion)))
SVN- или CVS-style попълването на ключови думи често се използва от разработчиците използващи тези системи.
Основният проблем с това в Git е, че не можете да файл с информация за къмита след като сте къмитнали, защото Git първо изчислява чексума за файла.
Обаче, можете да вмъквате текст във файл, когато файлът е извлечен и да го премахнете преди добавянето в къмит.
Git атрибутите предлагат два начина за това.

Първо, можете да вмъкнете SHA-1 чексумата на обект в `$Id$` поле във файлаавтоматично.
Ако зададете този атрибут за файл или множество файлове, тогава следващия път когато извлечете съдържанието на такъв клон Git ще замени това поле с SHA-1 стойността на обекта.
Важно е да се помни, че това не е SHA-1 на къмита, а на самия blob обект.
Сложете такъв ред в `.gitattributes`:

[source,ini]
----
*.txt ident
----

Добавете `$Id$` референция в пробен файл:

[source,console]
----
$ echo '$Id$' > test.txt
----

Следващия път, когато извлечете този файл Git вмъква SHA-1 на blob обекта:

[source,console]
----
$ rm test.txt
$ git checkout -- test.txt
$ cat test.txt
$Id: 42812b7653c7b88933f8a9d6cad0ca16714b9bb3 $
----

However, that result is of limited use.
If you've used keyword substitution in CVS or Subversion, you can include a datestamp – the SHA-1 isn't all that helpful, because it's fairly random and you can't tell if one SHA-1 is older or newer than another just by looking at them.

It turns out that you can write your own filters for doing substitutions in files on commit/checkout.
These are called ``clean'' and ``smudge'' filters.
In the `.gitattributes` file, you can set a filter for particular paths and then set up scripts that will process files just before they're checked out (``smudge'', see <<filters_a>>) and just before they're staged (``clean'', see <<filters_b>>).
These filters can be set to do all sorts of fun things.

[[filters_a]]
.The ``smudge'' filter is run on checkout.
image::images/smudge.png[The ``smudge'' filter is run on checkout.]

[[filters_b]]
.The ``clean'' filter is run when files are staged.
image::images/clean.png[The ``clean'' filter is run when files are staged.]

The original commit message for this feature gives a simple example of running all your C source code through the `indent` program before committing.
You can set it up by setting the filter attribute in your `.gitattributes` file to filter `*.c` files with the ``indent'' filter:

[source,ini]
----
*.c filter=indent
----

Then, tell Git what the ``indent'' filter does on smudge and clean:

[source,console]
----
$ git config --global filter.indent.clean indent
$ git config --global filter.indent.smudge cat
----

In this case, when you commit files that match `*.c`, Git will run them through the indent program before it stages them and then run them through the `cat` program before it checks them back out onto disk.
The `cat` program does essentially nothing: it spits out the same data that it comes in.
This combination effectively filters all C source code files through `indent` before committing.

Another interesting example gets `$Date$` keyword expansion, RCS style.
To do this properly, you need a small script that takes a filename, figures out the last commit date for this project, and inserts the date into the file.
Here is a small Ruby script that does that:

[source,ruby]
----
#! /usr/bin/env ruby
data = STDIN.read
last_date = `git log --pretty=format:"%ad" -1`
puts data.gsub('$Date$', '$Date: ' + last_date.to_s + '$')
----

All the script does is get the latest commit date from the `git log` command, stick that into any `$Date$` strings it sees in stdin, and print the results – it should be simple to do in whatever language you're most comfortable in.
You can name this file `expand_date` and put it in your path.
Now, you need to set up a filter in Git (call it `dater`) and tell it to use your `expand_date` filter to smudge the files on checkout.
You'll use a Perl expression to clean that up on commit:

[source,console]
----
$ git config filter.dater.smudge expand_date
$ git config filter.dater.clean 'perl -pe "s/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/"'
----

This Perl snippet strips out anything it sees in a `$Date$` string, to get back to where you started.
Now that your filter is ready, you can test it by setting up a Git attribute for that file that engages the new filter and creating a file with your `$Date$` keyword:

[source,ini]
----
date*.txt filter=dater
----

[source,console]
----
$ echo '# $Date$' > date_test.txt
----

If you commit those changes and check out the file again, you see the keyword properly substituted:

[source,console]
----
$ git add date_test.txt .gitattributes
$ git commit -m "Testing date expansion in Git"
$ rm date_test.txt
$ git checkout date_test.txt
$ cat date_test.txt
# $Date: Tue Apr 21 07:26:52 2009 -0700$
----

You can see how powerful this technique can be for customized applications.
You have to be careful, though, because the `.gitattributes` file is committed and passed around with the project, but the driver (in this case, `dater`) isn't, so it won't work everywhere.
When you design these filters, they should be able to fail gracefully and have the project still work properly.

==== Exporting Your Repository

(((archiving)))
Git attribute data also allows you to do some interesting things when exporting an archive of your project.

===== `export-ignore`

You can tell Git not to export certain files or directories when generating an archive.
If there is a subdirectory or file that you don't want to include in your archive file but that you do want checked into your project, you can determine those files via the `export-ignore` attribute.

For example, say you have some test files in a `test/` subdirectory, and it doesn't make sense to include them in the tarball export of your project.
You can add the following line to your Git attributes file:

[source,ini]
----
test/ export-ignore
----

Now, when you run `git archive` to create a tarball of your project, that directory won't be included in the archive.

===== `export-subst`

When exporting files for deployment you can apply `git log`'s formatting and keyword-expansion processing to selected portions of files marked with the
`export-subst` attribute.

For instance, if you want to include a file named `LAST_COMMIT` in your project, and have metadata about the last commit automatically injected into it when `git archive` runs, you can for example set up your `.gitattributes` and `LAST_COMMIT` files like this:

[source,ini]
----
LAST_COMMIT export-subst
----

[source,console]
----
$ echo 'Last commit date: $Format:%cd by %aN$' > LAST_COMMIT
$ git add LAST_COMMIT .gitattributes
$ git commit -am 'adding LAST_COMMIT file for archives'
----

When you run `git archive`, the contents of the archived file will look like this:

[source,console]
----
$ git archive HEAD | tar xCf ../deployment-testing -
$ cat ../deployment-testing/LAST_COMMIT
Last commit date: Tue Apr 21 08:38:48 2009 -0700 by Scott Chacon
----

The substitutions can include for example the commit message and any `git notes`, and `git log` can do simple word wrapping:

[source,console]
----
$ echo '$Format:Last commit: %h by %aN at %cd%n%+w(76,6,9)%B$' > LAST_COMMIT
$ git commit -am 'export-subst uses git log'\''s custom formatter

git archive uses git log'\''s `pretty=format:` processor
directly, and strips the surrounding `$Format:` and `$`
markup from the output.
'
$ git archive @ | tar xfO - LAST_COMMIT
Last commit: 312ccc8 by Jim Hill at Fri May 8 09:14:04 2015 -0700
       export-subst uses git log's custom formatter

         git archive uses git log's `pretty=format:` processor directly, and
         strips the surrounding `$Format:` and `$` markup from the output.
----

The resulting archive is suitable for deployment work, but like any exported archive it isn't suitable for further development work.

==== Merge Strategies

(((merging, strategies)))
You can also use Git attributes to tell Git to use different merge strategies for specific files in your project.
One very useful option is to tell Git to not try to merge specific files when they have conflicts, but rather to use your side of the merge over someone else's.

This is helpful if a branch in your project has diverged or is specialized, but you want to be able to merge changes back in from it, and you want to ignore certain files.
Say you have a database settings file called `database.xml` that is different in two branches, and you want to merge in your other branch without messing up the database file.
You can set up an attribute like this:

[source,ini]
----
database.xml merge=ours
----

And then define a dummy `ours` merge strategy with:

[source,console]
----
$ git config --global merge.ours.driver true
----

If you merge in the other branch, instead of having merge conflicts with the `database.xml` file, you see something like this:

[source,console]
----
$ git merge topic
Auto-merging database.xml
Merge made by recursive.
----

In this case, `database.xml` stays at whatever version you originally had.
