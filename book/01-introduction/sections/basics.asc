=== Основи на Git

И така, какво е Git?
Това е важна за усвояване секция, защото ако разберете какво е Git и какви са основите, върху които работи, тогава ползването му по един ефективен начин ще ви е доста по-лесно и приятно.
Изучавайки Git, опитайте се да се абстрахирате от нещата, които вече знаете за други VCS системи като Subversion или Perforce, това ще ви спести някои недоразумения и трудности.
Git съхранява и разглежда информацията съвсем различно в сравнение с другите системи, макар потребителският ѝ интерфейс да е подобен с техните. Разберете ли разликите, ще ви е по-лесно да работите с Git.(((Subversion)))(((Perforce)))

==== Snapshot-и вместо разлики

Основната разлика между Git и другите системи за контрол на версиите е начинът, по който Git третира данните.
Концептуално, повечето други системи записват информацията като списък от файлово-базирани промени.
Тези системи (CVS, Subversion, Perforce, Bazaar) виждат информацията, която съхраняват като колекция от файлове и промените направени във файловете във времето.

.Съхраняване на данните като списък от промени в базовата версия на всеки от файловете.
image::images/deltas.png[Съхраняване на данните като списък от промени в базовата версия на всеки от файловете.]

Git обаче, не третира информацията така.
Вместо това, Git възприема своите данни по-скоро като колекция от snapshots (моментни снимки на статуса) на една миниатюрна файлова система.
Всеки път когато къмитвате или записвате статуса на вашия проект в Git, системата най-общо казано прави снимка на това как изглеждат файловете ви в този момент и съхранява референция към този snapshot.
За ефективност, ако някои файлове не са променени, Git не ги записва отново, а просто записва указател към предишния идентичен файл, който вече е съхранил.
Така че - Git възприема своите данни като *поток от snapshot-и*.

.Записане на данните като поток от snapshot-и във времето.
image::images/snapshots.png[Git пази данните като поток от snapshot-и във времето.]

Това е важна разлика между Git и почти всички други VCS.
Git променя почти всеки един аспект на контрола на версиите, работейки подобно на малка файлова система с мощни инструменти, вместо да бъде просто VCS.
Ще разгледаме някои от предимствата, които дава тази концепция в главата посветена на клоновете код - Git branching <<_git_branching>>.

==== Почти всяка операция е локална

Повечето операции в Git се нуждаят само от локални файлове и ресурси - общо взето не се нуждаете от информация намираща се в мрежата.
Ако сте ползвали CVCS, където производителността на повечето операции зависи от мрежата, ще си помислите, че боговете на скоростта са благословили Git с извънземни сили.
Понеже разполагате с цялата история на проекта директно на диска, повечето операции изглеждат почти светкавични.

Например, за да ви покаже историята на проекта, Git не се нуждае да контактува със сървъра а просто чете директно от локалната си база данни и вие виждате историята почти незабавно.
Ако желаете да видите промените в даден файл между текущата му версия и тази отпреди месец, Git ще направи локална калкулация на разликите, вместо да трябва да пита отдалечения сървър за това или да трябва да издърпва по-стара версия от сървъра и едва след това да калкулира разликите локално.

Това също значи, че можете да правите почти всичко когато сте офлайн или когато VPN връзката ви не работи например.
Ако сте в самолет или влак и искате да свършите малко работа, можете спокойно да къмитвате промените си и когато имате мрежова връзка - да ги качите на сървър.
Ако сте вкъщи и VPN клиентът ви не работи - вие можете да продължите работата си.
В много други системи това е трудно или невъзможно.
В Perforce например, не можете да направите много офлайн, а в Subversion и CVS можете да редактирате файлове, но не можете д акъмитвате промените към базата данни (защото тя не е достъпна офлайн)

Това може да не изглежда толкова важно, но ще се изненадате каква разлика в стила ви на работа може да направи

==== Git има интегритет

Всичко в Git се проследява с чек-суми преди да се запише и след това обръщенията към съдържанието стават чрез чек-сумите.
Това означава, че е невъзможно да промените съдържанието на файл или директория без Git да знае за това.
Тази функционалност е вградена в Git на най-ниско ниво и е интегрална част от философията на системата.
Вие не можете да загубите информация в етапите на работа или да повредите файл без Git да го усети.

Механизмът, който Git използва за чек-сумите се нарича SHA-1 хеш.(((SHA-1)))
Това е 40-символен стринг съставен от шестнадесетични числа (0–9 и a–f) и калкулиран на базата на съдържанието на файл или структура на директория в Git.
Един SHA-1 хеш може да изглежда подобно на това:

[source]
----
24b9da6552252987aa493b52f8696cd6d3b00373
----

Ще срещате тези хешове почти навсякъде, защото Git ги ползва повсеместно.
В действителност, Git пази обектите в базата си данни не по имена на файлове, а посредством хешираните стрингове отразяващи съдържанието им.

==== Git само добавя данни

Когато правите нещо в Git, тези действия само добавят информация към базата данни на Git.
Трудно е да накарате системата да направи каквото и да е без то да може да бъде възстановено или пък да изтриете данни безвъзвратно.
Разбира се, подобно на всяка друга VCS, вие можете да загубите или объркате промените, които не са били къмитнати, но веднъж направили snapshot-а в Git - е много трудно да загубите данни, особено пък ако редовно изпращате базата си към отдалечено хранилище.

Това е хубавата страна на Git - знаем, че можем да експериментираме без опасност от тежки последствия.
За повече информация относно това как Git съхранява своите данни и как можете да възстановите информция, която изглежда загубена, погледнете <<_undoing>>.

==== Трите важни статуса

Сега внимавайте!
This is the main thing to remember about Git if you want the rest of your learning process to go smoothly.
Git has three main states that your files can reside in: committed, modified, and staged.
Committed means that the data is safely stored in your local database.
Modified means that you have changed the file but have not committed it to your database yet.
Staged means that you have marked a modified file in its current version to go into your next commit snapshot.


This leads us to the three main sections of a Git project: the Git directory, the working tree, and the staging area.

.Working tree, staging area, and Git directory.
image::images/areas.png["Working tree, staging area, and Git directory."]

The Git directory is where Git stores the metadata and object database for your project.
This is the most important part of Git, and it is what is copied when you clone a repository from another computer.

The working tree is a single checkout of one version of the project.
These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify.

The staging area is a file, generally contained in your Git directory, that stores information about what will go into your next commit.
It's sometimes referred to as the ``index'', but it's also common to refer to it as the staging area.

The basic Git workflow goes something like this:

1. You modify files in your working tree.
2. You stage the files, adding snapshots of them to your staging area.
3. You do a commit, which takes the files as they are in the staging area and stores that snapshot permanently to your Git directory.

If a particular version of a file is in the Git directory, it's considered committed.
If it has been modified and was added to the staging area, it is staged.
And if it was changed since it was checked out but has not been staged, it is modified.
In <<_git_basics_chapter>>, you'll learn more about these states and how you can either take advantage of them or skip the staged part entirely.
