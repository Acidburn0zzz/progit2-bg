=== Основи на Git

И така, какво е Git?
Това е важна за усвояване секция, защото ако разберете какво е Git и какви са основите, върху които работи, тогава ползването му по един ефективен начин ще ви е доста по-лесно и приятно.
Изучавайки Git, опитайте се да се абстрахирате от нещата, които вече знаете за други VCS системи като Subversion или Perforce, това ще ви спести някои недоразумения и трудности.
Git съхранява и разглежда информацията съвсем различно в сравнение с другите системи, макар потребителският ѝ интерфейс да е подобен с техните. Разберете ли разликите, ще ви е по-лесно да работите с Git.(((Subversion)))(((Perforce)))

==== Snapshot-и вместо разлики

Основната разлика между Git и другите системи за контрол на версиите е начинът, по който Git третира данните.
Концептуално, повечето други системи записват информацията като списък от файлово-базирани промени.
Тези системи (CVS, Subversion, Perforce, Bazaar) виждат информацията, която съхраняват като колекция от файлове и промените направени във файловете във времето.

.Съхраняване на данните като списък от промени в базовата версия на всеки от файловете.
image::images/deltas.png[Съхраняване на данните като списък от промени в базовата версия на всеки от файловете.]

Git обаче, не третира информацията така.
Вместо това, Git възприема своите данни по-скоро като колекция от snapshots (моментни снимки на статуса) на една миниатюрна файлова система.
Всеки път когато къмитвате или записвате статуса на вашия проект в Git, системата най-общо казано прави снимка на това как изглеждат файловете ви в този момент и съхранява референция към този snapshot.
За ефективност, ако някои файлове не са променени, Git не ги записва отново, а просто записва указател към предишния идентичен файл, който вече е съхранил.
Така че - Git възприема своите данни като *поток от snapshot-и*.

.Записане на данните като поток от snapshot-и във времето.
image::images/snapshots.png[Git пази данните като поток от snapshot-и във времето.]

Това е важна разлика между Git и почти всички други VCS.
Git променя почти всеки един аспект на контрола на версиите, работейки подобно на малка файлова система с мощни инструменти, вместо да бъде просто VCS.
Ще разгледаме някои от предимствата, които дава тази концепция в главата посветена на клоновете код - Git branching <<_git_branching>>.

==== Почти всяка операция е локална

Повечето операции в Git се нуждаят само от локални файлове и ресурси - общо взето не се нуждаете от информация намираща се в мрежата.
Ако сте ползвали CVCS, където производителността на повечето операции зависи от мрежата, ще си помислите, че боговете на скоростта са благословили Git с извънземни сили.
Понеже разполагате с цялата история на проекта директно на диска, повечето операции изглеждат почти светкавични.

Например, за да ви покаже историята на проекта, Git не се нуждае да контактува със сървъра а просто чете директно от локалната си база данни и вие виждате историята почти незабавно.
Ако желаете да видите промените в даден файл между текущата му версия и тази отпреди месец, Git ще направи локална калкулация на разликите, вместо да трябва да пита отдалечения сървър за това или да трябва да издърпва по-стара версия от сървъра и едва след това да калкулира разликите локално.

Това също значи, че можете да правите почти всичко когато сте офлайн или когато VPN връзката ви не работи например.
Ако сте в самолет или влак и искате да свършите малко работа, можете спокойно да къмитвате промените си и когато имате мрежова връзка - да ги качите на сървър.
Ако сте вкъщи и VPN клиентът ви не работи - вие можете да продължите работата си.
В много други системи това е трудно или невъзможно.
В Perforce например, не можете да направите много офлайн, а в Subversion и CVS можете да редактирате файлове, но не можете д акъмитвате промените към базата данни (защото тя не е достъпна офлайн)

Това може да не изглежда толкова важно, но ще се изненадате каква разлика в стила ви на работа може да направи

==== Git Has Integrity

Everything in Git is check-summed before it is stored and is then referred to by that checksum.
This means it's impossible to change the contents of any file or directory without Git knowing about it.
This functionality is built into Git at the lowest levels and is integral to its philosophy.
You can't lose information in transit or get file corruption without Git being able to detect it.

The mechanism that Git uses for this checksumming is called a SHA-1 hash.(((SHA-1)))
This is a 40-character string composed of hexadecimal characters (0–9 and a–f) and calculated based on the contents of a file or directory structure in Git.
A SHA-1 hash looks something like this:

[source]
----
24b9da6552252987aa493b52f8696cd6d3b00373
----

You will see these hash values all over the place in Git because it uses them so much.
In fact, Git stores everything in its database not by file name but by the hash value of its contents.

==== Git Generally Only Adds Data

When you do actions in Git, nearly all of them only add data to the Git database.
It is hard to get the system to do anything that is not undoable or to make it erase data in any way.
As in any VCS, you can lose or mess up changes you haven't committed yet; but after you commit a snapshot into Git, it is very difficult to lose, especially if you regularly push your database to another repository.

This makes using Git a joy because we know we can experiment without the danger of severely screwing things up.
For a more in-depth look at how Git stores its data and how you can recover data that seems lost, see <<_undoing>>.

==== The Three States

Now, pay attention.
This is the main thing to remember about Git if you want the rest of your learning process to go smoothly.
Git has three main states that your files can reside in: committed, modified, and staged.
Committed means that the data is safely stored in your local database.
Modified means that you have changed the file but have not committed it to your database yet.
Staged means that you have marked a modified file in its current version to go into your next commit snapshot.

This leads us to the three main sections of a Git project: the Git directory, the working tree, and the staging area.

.Working tree, staging area, and Git directory.
image::images/areas.png["Working tree, staging area, and Git directory."]

The Git directory is where Git stores the metadata and object database for your project.
This is the most important part of Git, and it is what is copied when you clone a repository from another computer.

The working tree is a single checkout of one version of the project.
These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify.

The staging area is a file, generally contained in your Git directory, that stores information about what will go into your next commit.
It's sometimes referred to as the ``index'', but it's also common to refer to it as the staging area.

The basic Git workflow goes something like this:

1. You modify files in your working tree.
2. You stage the files, adding snapshots of them to your staging area.
3. You do a commit, which takes the files as they are in the staging area and stores that snapshot permanently to your Git directory.

If a particular version of a file is in the Git directory, it's considered committed.
If it has been modified and was added to the staging area, it is staged.
And if it was changed since it was checked out but has not been staged, it is modified.
In <<_git_basics_chapter>>, you'll learn more about these states and how you can either take advantage of them or skip the staged part entirely.
