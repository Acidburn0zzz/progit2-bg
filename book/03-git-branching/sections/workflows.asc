=== Стратегии за работа с клонове код

След като вече имате основните познания за разклоняване и сливане на код, нека видим какво можете и следва да правите с тях.
Тук ще разгледаме някои стандартни стратегии за работа с клонове код, които стават възможни благодарение на лекотата, с която Git управлява разклоненията. Може да решите да използвате някои от тях във вашия цикъл на разработки.

==== Дълго използвани клонове

(((branches, long-running)))
Понеже Git използва просто трипосочно сливане, сливането на един клон с друг много пъти в продължение на дълъг период от време, е много лесно.
Това означава, че можете да имате множество клонове, които са винаги отворени и които можете да ползвате за различни етапи на вашия цикъл от разработки и редовно да правите сливания на промените от един клон в друг.

Много разработчици, които ползват Git, следват подобна тактика - в `master` клона държат само напълно стабилния код, който вече публикуван или ще бъде публикуван.
Те имат отделен паралелен клон наречен `develop` или `next`, от който работят или тестват за стабилност - този код не е непременно стабилен, но щом стане такъв, може да се слее в `master` клона.
Той се използва за създаването на допълнителни topic branches (клонове с кратък живот, подобни на вашия `iss53`) когато са готови, за да е сигурно, че те преминават всички тестове и не предизвикват грешки.

В действителност, говорим за указатели, които се преместват по линията на къмитите, които правим.
Стабилните клонове са в долния край на линията на историята на къмитите, а най-новите - в горния край

.Линеен изглед на progressive-stability разклоняване
image::images/lr-branches-1.png[Линеен изглед на progressive-stability разклоняване.]

За улеснение, можем да мислим за тях като за работни помещения, където множествата къмити преминават към "по-стабилно" помещение, когато се изтестват напълно.


[[lrbranch_b]]
.Разклонен изглед на progressive-stability разклоняване
image::images/lr-branches-2.png[Разклонен изглед на progressive-stability разклоняване.]

Можете да правите това за различни нива на стабилност.
Някои по-големи проекти също така имат `proposed` или `pu` (proposed updates) клон интегриращ други такива, които може да не са готови да отидат в `next` или `master` клона.
Идеята е, че клоновете код са с различни нива на стабилност и когато достигнат по-стабилен статус - се сливат с клона над тях.
Да припомним отново - поддържането на long-running клонове не е необходимо, но често е полезно, особено когато си имате работа с много големи и сложни проекти.

[[_topic_branch]]
==== Topic Branches

(((branches, topic)))
Topic branches, however, are useful in projects of any size.
A topic branch is a short-lived branch that you create and use for a single particular feature or related work.
This is something you've likely never done with a VCS before because it's generally too expensive to create and merge branches.
But in Git it's common to create, work on, merge, and delete branches several times a day.

You saw this in the last section with the `iss53` and `hotfix` branches you created.
You did a few commits on them and deleted them directly after merging them into your main branch.
This technique allows you to context-switch quickly and completely – because your work is separated into silos where all the changes in that branch have to do with that topic, it's easier to see what has happened during code review and such.
You can keep the changes there for minutes, days, or months, and merge them in when they're ready, regardless of the order in which they were created or worked on.

Consider an example of doing some work (on `master`), branching off for an issue (`iss91`), working on it for a bit, branching off the second branch to try another way of handling the same thing (`iss91v2`), going back to your `master` branch and working there for a while, and then branching off there to do some work that you're not sure is a good idea (`dumbidea` branch).
Your commit history will look something like this:

.Multiple topic branches
image::images/topic-branches-1.png[Multiple topic branches.]

Now, let's say you decide you like the second solution to your issue best (`iss91v2`); and you showed the `dumbidea` branch to your coworkers, and it turns out to be genius.
You can throw away the original `iss91` branch (losing commits `C5` and `C6`) and merge in the other two.
Your history then looks like this:

.History after merging `dumbidea` and `iss91v2`
image::images/topic-branches-2.png[History after merging `dumbidea` and `iss91v2`.]

We will go into more detail about the various possible workflows for your Git project in <<_distributed_git>>, so before you decide which branching scheme your next project will use, be sure to read that chapter.

It's important to remember when you're doing all this that these branches are completely local.
When you're branching and merging, everything is being done only in your Git repository – no server communication is happening.
