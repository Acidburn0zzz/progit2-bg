=== Основи на клоновете код и сливането

Нека илюстрираме разклоняването и сливането с малък пример, какъвто може да срещнете в реалния живот.
Ще следваме следните стъпки:

. Работите по уеб сайт.
. Създавате нов клон за нова статия, по която работите.
. Извършвате някакви дейности по този клон.

В този момент, получавате обаждане за внезапно възникнал критичен проблем в друга част от сайта, който трябва да решите бързо.
Ще направите следното:

. Превключвате към работния production клона.
. Създавате нов клон и решавате проблема в него.
. След тест, че всичко в поправката е наред, сливате hotfix клона обратно в работния клон.
. Превключвате отново към клона с новата статия и продължавате работа.

[[_basic_branching]]
==== Основи на разклоняването

(((branches, basic workflow)))
Първо, нека приемем, че работите по проекта си и вече имате няколко къмита.

.Проста история на къмитите
image::images/basic-branching-1.png[Проста история на къмитите.]

Решили сте, че трябва да работите по проблем #53 в issue-tracking системата, която ползва вашата компания.
За да създадете клон и превключите към него в същия момент, изпълнете командата `git checkout` с параметър `-b`:

[source,console]
----
$ git checkout -b iss53
Switched to a new branch "iss53"
----

Това е съкратена версия на командите:

[source,console]
----
$ git branch iss53
$ git checkout iss53
----

.Създаване на нов указател към branch
image::images/basic-branching-2.png[Създаване на нов указател към branch.]

Вие си работите по сайта и правите няколко къмита.
По време на този процес, клонът `iss53` се премества напред, защото е текущ (това означава, че `HEAD` указателят сочи към него):

[source,console]
----
$ vim index.html
$ git commit -a -m 'added a new footer [issue 53]'
----

.Клонът `iss53` се е преместил напред в процеса на работа
image::images/basic-branching-3.png[Клонът `iss53` се е преместил напред в процеса на работа.]

Сега получавате обажданете, че нещо не е наред с уебсайта и трябва да го оправите незабавно.
С Git, не е нужно да прилагате поправката заедно с промените, които се съдържат в `iss53` клона и не е нужно да влагате усилия по отмяната на тези промени преди да можете да приложите спешната поправка в production версията на сайта.
Всичко, което трябва да направите е да превключите обратно към `master` клона.

Обаче, преди да направите това, отбележете, че ако работната ви директория или индексната област съдържат некъмитнати промени, които влизат в конфликт с клона, към който превключвате Git няма да позволи превключването на клоновете.
Най-добре е да имате чист работен статус преди превключването.
Съществуват начини да заобиколите това (известно като stashing и commit amending), които ще разгледаме по-късно в <<_git_stashing>>.
Засега, нека приемем, че сте къмитнали промените си, така че може да се върнете в `master` клона:

[source,console]
----
$ git checkout master
Switched to branch 'master'
----

В този момент, работната ви директория ще се превърти обратно до съдържанието, което е имала преди да започнете работа по проблем 53 и можете да се концентрирате в спешната поправка, която е необходимо да въведете.
Това е важен момент за запомняне: когато превключвате между клоновете, Git ресетва работната директория до статуса в която е била последния път когато сте къмитнали в този клон.
Системата добавя, изтрива и променя файловете автоматично, за да ви предостави работното копие на обектите в момента на последния ви къмит.

След това, имате да правите спешната поправка.
Нека създаден един hotfix клон, по който да работим докато тя стане готова:

[source,console]
----
$ git checkout -b hotfix
Switched to a new branch 'hotfix'
$ vim index.html
$ git commit -a -m 'fixed the broken email address'
[hotfix 1fb7853] fixed the broken email address
 1 file changed, 2 insertions(+)
----

.Hotfix клон произлизащ от `master` клона
image::images/basic-branching-4.png[Hotfix клон произлизащ от `master` клона.]

Можете да пускате тестовете си, да се уверите, че поправката работи както се очаква и да слеете обратно вашия hotfix клон в `master` клона за да го пуснете в работния вариант.
Това се прави с командата `git merge`:(((git commands, merge)))

[source,console]
----
$ git checkout master
$ git merge hotfix
Updating f42c576..3a0874c
Fast-forward
 index.html | 2 ++
 1 file changed, 2 insertions(+)
----

В съобщението от сливането ще забележите фразата ``fast-forward''.
Понеже къмитът `C4` към който сочи клона `hotfix`, който сляхте, беше директно след къмита `C2`, Git просто премества указателя напред.
Казано по друг начин, когато се опитвате да слеете един къмит с друг такъв, който може да бъде достигнат следвайки историята на първия, Git опростява нещата премествайки указателя напред, защото не се налага да се върши работа по сливане на разклонен код. Това се нарича ``fast-forward.''

Сега промяната ви е в snapshot-а на къмита сочен от `master` клона и можете да пуснете промяната в реалния сайт.

.`master` е превъртян (fast-forwarded) към `hotfix`
image::images/basic-branching-5.png[`master` е превъртян (fast-forwarded) към `hotfix`.]

След като суперважната промяна е въведена, можете да се върнете обратно към работата, която вършехте преди обаждането.
Обаче, първо ще изтриете клона `hotfix`, понеже вече не ви е нужен - `master` клонът сочи към същото място.
Изтриването се прави с параметъра `-d` на командата `git branch`:

[source,console]
----
$ git branch -d hotfix
Deleted branch hotfix (3a0874c).
----

Сега можете да се прехвърлите към клона, в който си вършите обичайната работа по проблем 53 и да си я продължите.

[source,console]
----
$ git checkout iss53
Switched to branch "iss53"
$ vim index.html
$ git commit -a -m 'finished the new footer [issue 53]'
[iss53 ad82d7a] finished the new footer [issue 53]
1 file changed, 1 insertion(+)
----

.Работата продължава в клона `iss53`
image::images/basic-branching-6.png[Работата продължава в клона `iss53`.]

Тук си струва да отбележим, че промените, които направихте в клона `hotfix` не се съдържат във файловете на клона `iss53`.
Ако искате да ги имате, можете да слеете `master` клона в `iss53` изпълнявайки `git merge master`, или пък можете да изчакате с интегрирането на тези промени докато дойде момента, в който решите че е време да слеете `iss53` клона обратно в `master`.


[[_basic_merging]]
==== Сливане

(((branches, merging)))(((merging)))
Да кажем, че сте решили, че работата по проблем 53 е свършена и сте готови да я слеете в `master` клона.
За да направите това, ще действате по същия начин, по който го направихте с клона `hotfix` по-рано.
Всичко, което трябва да направите е да превключите към клона в който искате да сливате и да изпълните `git merge`:

[source,console]
----
$ git checkout master
Switched to branch 'master'
$ git merge iss53
Merge made by the 'recursive' strategy.
index.html |    1 +
1 file changed, 1 insertion(+)
----

Това обаче изглежда по-различно от `hotfix` сливането.
В този случай, историята на разработката се е отклонила от по-ранна точка.
Понеже къмитът на клона, в който сте (С4), не е директен предшественик на клона, който сливате, Git ще има малко работа за вършене.
В този случай, Git прави просто трипосочно сливане използвайки двата snapshot-а на клоновете и общия им предшественик (С2).

.Три snapshot-а използвани в типично сливане
image::images/basic-merging-1.png[Три snapshot-а използвани в типично сливане.]

This is referred to as a merge commit, and is special in that it has more than one parent.
Вместо просто да премести указателя на клона напред, Git създава нов snapshot, който е резултат от това трипосочно сливане и автоматично създава нов къмит, който да сочи към него.

.Сливащ commit
image::images/basic-merging-2.png[Сливащ commit.]

Заслужава си да отбележим също така, че Git определя най-добрия общ предшественик за база на сливането; това е различно от начина на работа в CVS или Subversion (преди версия 1.5), където разработчикът правещ сливането трябва сам да определи най-добрата изходна точка за сливането.
Това прави сливането в Git много по-лесно, отколкото в другите системи.

Сега, когато работата ви е слята, вече не се нуждаете от клона `iss53`.
Можете да затворите тикета в ticket-tracking системата и да изтиете клона:

[source,console]
----
$ git branch -d iss53
----

[[_basic_merge_conflicts]]
==== Конфликти при сливане

(((merging, conflicts)))
Occasionally, this process doesn't go smoothly.
If you changed the same part of the same file differently in the two branches you're merging together, Git won't be able to merge them cleanly.
If your fix for issue #53 modified the same part of a file as the `hotfix`, you'll get a merge conflict that looks something like this:

[source,console]
----
$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
----

Git hasn't automatically created a new merge commit.
It has paused the process while you resolve the conflict.
If you want to see which files are unmerged at any point after a merge conflict, you can run `git status`:

[source,console]
----
$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add <file>..." to mark resolution)

    both modified:      index.html

no changes added to commit (use "git add" and/or "git commit -a")
----

Anything that has merge conflicts and hasn't been resolved is listed as unmerged.
Git adds standard conflict-resolution markers to the files that have conflicts, so you can open them manually and resolve those conflicts.
Your file contains a section that looks something like this:

[source,html]
----
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div>
>>>>>>> iss53:index.html
----

This means the version in `HEAD` (your `master` branch, because that was what you had checked out when you ran your merge command) is the top part of that block (everything above the `=======`), while the version in your `iss53` branch looks like everything in the bottom part.
In order to resolve the conflict, you have to either choose one side or the other or merge the contents yourself.
For instance, you might resolve this conflict by replacing the entire block with this:

[source,html]
----
<div id="footer">
please contact us at email.support@github.com
</div>
----

This resolution has a little of each section, and the `<<<<<<<`, `=======`, and `>>>>>>>` lines have been completely removed.
After you've resolved each of these sections in each conflicted file, run `git add` on each file to mark it as resolved.
Staging the file marks it as resolved in Git.

If you want to use a graphical tool to resolve these issues, you can run `git mergetool`, which fires up an appropriate visual merge tool and walks you through the conflicts:(((git commands, mergetool)))

[source,console]
----
$ git mergetool

This message is displayed because 'merge.tool' is not configured.
See 'git mergetool --tool-help' or 'git help config' for more details.
'git mergetool' will now attempt to use one of the following tools:
opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge
Merging:
index.html

Normal merge conflict for 'index.html':
  {local}: modified file
  {remote}: modified file
Hit return to start merge resolution tool (opendiff):
----

If you want to use a merge tool other than the default (Git chose `opendiff` in this case because the command was run on a Mac), you can see all the supported tools listed at the top after ``one of the following tools.''
Just type the name of the tool you'd rather use.

[NOTE]
====
If you need more advanced tools for resolving tricky merge conflicts, we cover more on merging in <<_advanced_merging>>.
====

After you exit the merge tool, Git asks you if the merge was successful.
If you tell the script that it was, it stages the file to mark it as resolved for you.
You can run `git status` again to verify that all conflicts have been resolved:

[source,console]
----
$ git status
On branch master
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:

    modified:   index.html
----

If you're happy with that, and you verify that everything that had conflicts has been staged, you can type `git commit` to finalize the merge commit.
The commit message by default looks something like this:

[source,console]
----
Merge branch 'iss53'

Conflicts:
    index.html
#
# It looks like you may be committing a merge.
# If this is not correct, please remove the file
#	.git/MERGE_HEAD
# and try again.


# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# All conflicts fixed but you are still merging.
#
# Changes to be committed:
#	modified:   index.html
#
----

If you think it would be helpful to others looking at this merge in the future, you can modify this commit message with details about how you resolved the merge and explain why you did the changes you made if these are not obvious.
