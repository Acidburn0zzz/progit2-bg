=== Комуникационни протоколи

Git може да използва 4 основни протокола за трансфер на данни: локален, HTTP, Secure Shell (SSH) и Git.
Сега ще погледнем какво представляват те и по какви причини бихте желали да ги използвате (или избягвате).

==== Локален протокол

(((protocols, local)))
Най-простият от четирите е _локалния протокол_, при който отдалеченото хранилище се намира просто в друга директория на доска.
Това често се ползва, ако всички в екипа ви имат достъп до споделена файлова система от рода на NFS споделено устройство или пък, в по-редки случаи, когато всички се логват на един и същи компютър.
Последното не е препоръчително, защото всички копия на хранилището ще се пазят на едно място и рискът от загубата на данни при хардуерна повреда е значително по-голям.

Ако имате споделена монтирана файлова система, тогава вие клонирате, изпращате и изтегляте данни от локално, файлово-базирано хранилище.
За да клонирате хранилище от този вид или за да добавите такова като отдалечено към съществуващ проект, използвайте пътя до хранилището вместо URL.
Например, за да клонирате, може да изпълните нещо подобо:

[source,console]
----
$ git clone /srv/git/project.git
----

Или пък така:

[source,console]
----
$ git clone file:///srv/git/project.git
----

Git работи малко по-различно ако изрично укажете `file://` като префикс на пътя.
Ако укажете само пътя, системата се опитва да използва hardlinks или директно копира файловете, които са нужни.
Ако укажете `file://`, Git ще стартира процеси, които нормално се използват за мрежов трансфер, което е една идея по-малко ефективен метод за трансфер на данни.
Главната причина да използвате префикса `file://` е, че можете да искате чисто копие на хранилището, без неприсъщи референции или обекти в него - основно при импорт от други VCS системи или нещо подобно (вижте <<_git_internals>> за повече подробности).
Тук ние ще използваме нормални пътища, защото това почти винаги работи по-бързо.

За да добавите локално хранилище като remote към съществуващ Git проект, можете да направите това:

[source,console]
----
$ git remote add local_proj /srv/git/project.git
----

След това, можете да изпращате и издърпвате от него по същия начин, по който ако то беше в мрежа.

===== Предимствата

Предимствата на файл-базираните хранилища са в това, че са прости и използват наличните права за файловете и мрежовия достъп.
Ако вече имате споделена файлова система, до която има достъп целия ви екип, създаването на хранилище е много просто.
Пазите копие от bare хранилището някъде, където всички имат достъп и задавате права за чете и писане като на всяка друга споделена директория.
Ще дискутираме как да експортирате копие от хранилището като bare копие за целта в <<_git_on_the_server>>.

Това също е полезен начин за бързо изтегляне на работата на друг човек от неговото работещо хранилище.
Ако с ваш колега работите по един и същи проект и той поиска да погледнете нещо по неговата работа, то една команда от рода на `git pull /home/john/project` вероятно ще е по-лесна опция от това той да изпрати нещо до мрежовото хранилище а вие след това да го теглите при вас.

===== Недостатъци

Неудобствата при този подход се състяот в това, че споделеният достъп в повечето случаи се настройва и достъпва от различни локации по-трудно в сравнение със стандартния мрежов достъп.
Ако искате да изпратите данни от домашния си лаптоп, докато сте вкъщи, ще трябва да монтирате отдалечения диск, което често може да е трудно и досадно бавно.

Също така трябва да посочим, че локалния протокол не винаги е най-бързата опция, ако изпозлвате споделен монторан ресурс от някои видове.
Локалното хранилище е бързо само, ако имате бърз достъп до данните.
Едно хранилище разположено върху NFS ресурс често е по-бавно от SSH такова на същия сървър (което освен това позволява на Git да работи през локалните дискове на всеки от компютрите).

Накрая, този протокол не защитава хранилището от непредвидени поражения.
Всеки потребител разполага с пълен шел достъп до "отдалеченото" хранилище и нищо не пречи на един невнимателен колега да промени или изтрие служебни Git файлове, което от своя страна да повреди цялото хранилище.

==== HTTP протоколите

Git може да работи през HTTP в два различни режима.
Преди Git версия 1.6.6, начинът беше само един и то доста опростен и в общия случай - read-only.
С тази версия обаче, беше представен нов, по-усъвършенстван протокол, който позволява на Git интелигентно да уговаря транфера на данни по маниер подобен на този, който се използва през SSH.
В последните няколко години този нов HTTP протокол придоби голяма популярност, защото е по-прост за потребителя и по-интелигентен в механизма на комуникация.
Тази нова версия често е наричана ``Smart'' HTTP протокол, докато старата е известна като ``Dumb'' HTTP.
Ще разгледаме първо ``smart'' HTTP протокола.

===== Smart HTTP

(((protocols, smart HTTP)))
Протоколът ``smart'' HTTP работи много подобно на SSH или Git протоколите, но използва стандартните HTTP/S портове и може да използва различни механизми за HTTP автентикация, което често го прави по-лесен за много потребители, защото можете да използвате неща като оторизиране с име и парола, вместо създаване на SSH ключове.

Този протокол в момента е най-популярния начин за използване в Git, понеже може да работи както анонимно, подобно на протокола `git://`, така и с криптиране подобно на SSH и автентикация.
Вместо да създавате различни URLи за тези неща, сега можете да използвате единичен URL за всички тях.
Ако се опитате да изпратите данни към хранилище настроено да изисква оторизация (както би следвало да е), сървърът може да ви попита за потребителско име и парола за достъп.
Същото важи и за достъпа само за четене.

На практика, в услуги като GitHub, URL-ът който ползвате за да разглеждате хранилището в браузъра (например, ``https://github.com/schacon/simplegit[]'') е същият URL, който можете да използвате за клонирането му или пък за изпращане на промени към него (ако имате права за това).

===== Dumb HTTP

(((protocols, dumb HTTP)))
Ако сървърът не разполага с Git HTTP smart услуга, Git клиентът ще се опита да използва протокола ``dumb'' HTTP.
Този вид комуникация очаква bare Git хранилището да се обслужва като нормални файлове от уеб сървъра.
Красотата на dumb протокола се крие в простотата на настройката му.
В общи линии, всичко което трябва да направите е да копирате едно bare Git хранилище там където уеб сървърът има достъп и да настроите специфичен `post-update` hook, след което сте готови (вижте <<_git_hooks>>).
Сега всички, които имат достъп до уеб сървъра, ще могат да клонират хранилището ви.
За да позволите достъп за четене до хранилището през HTTP, направете нещо такова:

[source,console]
----
$ cd /var/www/htdocs/
$ git clone --bare /path/to/git_project gitproject.git
$ cd gitproject.git
$ mv hooks/post-update.sample hooks/post-update
$ chmod a+x hooks/post-update
----

Това е всичко.(((hooks, post-update)))
Инструментът `post-update`, който идва с Git, по подразбиране изпълнява съответната команда (`git update-server-info`) така че HTTP издърпването и клонирането да работят коректно.
Тази команда се изпълнява когато изпращате към това хранилище, вероятно през SSH, след което други потребители могат да клонират посредством нещо такова:

[source,console]
----
$ git clone https://example.com/gitproject.git
----

В този специфичен случай, ние използваме `/var/www/htdocs` пътя, който е стандартен за Apache инсталациите, но вие можете да ползвате който и да е статичен уеб сървър - просто сложете bare хранилището в неговия път.
Git данните се обслужват като базови статични файлове (вижте <<_git_internals>> за повече информация как точно става това).

Kато обобщение, имате два избора, да пуснете read/write Smart HTTP сървър или read-only такъв с Dumb HTTP.
Рядко се случва да се прави комбинация от двете.

===== Предимствата

Ще разгледаме предимствата на Smart HTTP версията на протокола.

Простотата да имате единичен URL за всички видове достъп и да оставите сървърът да пита за име и парола, когато се налага, прави нещата много по-лесни за крайния потребител.
Възможността за оторизация с име и парола е голямо предимство сравнена с SSH, защото потребителите няма нужда да генерират SSH ключове локално и да изпращат публичния си ключ към сървъра преди да могат да комуникират с него.
За по-неопитните потребители или за потребителите на системи, в които SSH не се ползва интензивно, това може да бъде голямо улеснение по отношение на лекотата на ползване.
В допълнение, протоколът е бърз и ефективен, подобно на SSH.

Можете също да обслужвате хранилищата си само за четене през HTTPS, което значи че можете да криптирате съдържанието на трансфера или дори да стигнете и до по-рестриктивни мерки, като например да изисквате от клиентите да използват специфични signed SSL сертификати.

Друго предимство е и факта, че HTTP/S са толкова разпространени протоколи, че корпоративните защитни стени често вече са настроени да пропускат трафика през техните портове.

===== Недостатъци

Git през HTTP/S може да е една идея по-сложен за настройване в сравнение с SSH на някои сървъри.
Отделно от това, съществува съвсем леко предимство, което другите протоколи за обслужване на Git имат, в сравнение със ``Smart'' HTTP. 

Ако използвате HTTP за автентикирано изпращане на промени към хранилището, изпращането на името и паролата понякога може да е малко по-сложно отколкото използването на SSH ключове.
Обаче, съществуват няколко credential caching инструменти, които можете да ползвате, включително Keychain access на OSX или Credential Manager под Windows, за да си улесните нещата.
Погледнете <<_credential_caching>>, за да видите как да настроите системата за защитено кеширане на HTTP пароли.

==== The SSH Protocol

(((protocols, SSH)))
A common transport protocol for Git when self-hosting is over SSH.
This is because SSH access to servers is already set up in most places – and if it isn't, it's easy to do.
SSH is also an authenticated network protocol; and because it's ubiquitous, it's generally easy to set up and use.

To clone a Git repository over SSH, you can specify ssh:// URL like this:

[source,console]
----
$ git clone ssh://user@server/project.git
----

Or you can use the shorter scp-like syntax for the SSH protocol:

[source,console]
----
$ git clone user@server:project.git
----

You can also not specify a user, and Git assumes the user you're currently logged in as.

===== The Pros

The pros of using SSH are many.
First, SSH is relatively easy to set up – SSH daemons are commonplace, many network admins have experience with them, and many OS distributions are set up with them or have tools to manage them.
Next, access over SSH is secure – all data transfer is encrypted and authenticated.
Last, like the HTTP/S, Git and Local protocols, SSH is efficient, making the data as compact as possible before transferring it.

===== The Cons

The negative aspect of SSH is that you can't serve anonymous access of your repository over it.
People must have access to your machine over SSH to access it, even in a read-only capacity, which doesn't make SSH access conducive to open source projects.
If you're using it only within your corporate network, SSH may be the only protocol you need to deal with.
If you want to allow anonymous read-only access to your projects and also want to use SSH, you’ll have to set up SSH for you to push over but something else for others to fetch over.

==== The Git Protocol

(((protocols, git)))
Next is the Git protocol.
This is a special daemon that comes packaged with Git; it listens on a dedicated port (9418) that provides a service similar to the SSH protocol, but with absolutely no authentication.
In order for a repository to be served over the Git protocol, you must create the `git-daemon-export-ok` file – the daemon won't serve a repository without that file in it – but other than that there is no security.
Either the Git repository is available for everyone to clone or it isn't.
This means that there is generally no pushing over this protocol.
You can enable push access; but given the lack of authentication, if you turn on push access, anyone on the internet who finds your project's URL could push to your project.
Suffice it to say that this is rare.

===== The Pros

The Git protocol is often the fastest network transfer protocol available.
If you’re serving a lot of traffic for a public project or serving a very large project that doesn't require user authentication for read access, it’s likely that you'll want to set up a Git daemon to serve your project.
It uses the same data-transfer mechanism as the SSH protocol but without the encryption and authentication overhead.

===== The Cons

The downside of the Git protocol is the lack of authentication.
It's generally undesirable for the Git protocol to be the only access to your project.
Generally, you'll pair it with SSH or HTTPS access for the few developers who have push (write) access and have everyone else use `git://` for read-only access.
It's also probably the most difficult protocol to set up.
It must run its own daemon, which requires `xinetd` configuration or the like, which isn't always a walk in the park.
It also requires firewall access to port 9418, which isn't a standard port that corporate firewalls always allow.
Behind big corporate firewalls, this obscure port is commonly blocked.
