[[_maintaining_gh_project]]
=== Управление на проект

След като вече сме готови да сътрудничим в проекти на други хора, ще погледнем и обратната страна: създаване, поддържане и администриране на собствен проект.

==== Създаване на хранилище

Нека създадем ново хранилище, чийто код да споделим с другите.
Започваме натискайки бутона ``New repository'' в дясната част на екрана или натискайки бутона `+` в горния туулбар до потребителското ни име както можем да видим в <<_new_repo_dropdown>>.

.Частта ``Your repositories''.
image::images/newrepo.png[Частта ``Your repositories''.]

[[_new_repo_dropdown]]
.Падащият списък ``New repository''.
image::images/new-repo.png[Падащият списък ``New repository''.]

Това ни прехвърля към формата ``new repository'':

.The ``new repository'' form.
image::images/newrepoform.png[The ``new repository'' form.]

На практика, единственото задължително поле е това с името на проекта, всички останали са незадължителни.
Засега просто натиснете бутона ``Create Repository'' и вече разполагате с ново хранилище в GitHub, с име `<user>/<project_name>`.

Понеже все още нямате качен никакъв код, GitHub ще ви предложи инструкции как да създадете ново Git хранилище или да се свържете със съществуващ Git проект.
Няма да навлизаме в детайли за това, ако имате нужда от припомняне, погледнете  <<_git_basics_chapter#_git_basics_chapter>>.

Сега проектът ви се хоства в GitHub и можете да изпратите URL-а на всеки, с който желаете да го споделите.
Всеки GitHub проект е достъпен през HTTPS като `https://github.com/<user>/<project_name>`, а също и през SSH като `git@github.com:<user>/<project_name>`.
Git може да тегли и да изпраща и по двата начина, а достъпът се контролира с правата на името и паролата на свързващия се потребител.

[NOTE]
====
Често се предпочита HTTPS-базирания достъп, понеже по този начин външния потребител може да клонира проект и без да има GitHub акаунт.
Ако някой потребител предпочита SSH достъп, то той трябва да има акаунт и качен SSH ключ.
HTTPS адресът е същият, който потребителят би написал в браузъра си за уеб базиран достъп до проекта.
====

==== Добавяне на сътрудници

Ако работите с други хора по проекта си и желаете да им дадете възможност да правят къмити, трябва да ги добавите към проекта като ``collaborators''.
Ако Ben, Jeff, и Louise имат GitHub акаунти и искате да има дадете Push достъп до вашето хранилище, можете да ги добавите към проекта, така че да могат както да четат, така и да пишат в кода.

Натиснете линка ``Settings'' в дъното на дясната част.

.Препратката settings за хранилището.
image::images/reposettingslink.png[Препратката settings за хранилището.]

След това, изберете ``Collaborators'' от менюто вляво.
Въведете потребителското име, което желаете и щракнете``Add collaborator.''
Можете да повторите това за колкото други потребителя желаете.
Ако искате пък да отнемете достъпа, просто щракнете ``X'' иконата в дясната част на съответния ред.

.Сътрудници в хранилище.
image::images/collaborators.png[Сътрудници в хранилище.]

==== Управление на Pull Requests

Сега вече имате проект с код в него и може би няколко сътрудника с push достъп до хранилището - нека да видим какво да направите, когато получите Pull Request.

Pull Request-ите могат да дойдат от клон, който се намира във fork на проекта ви или пък от друг клон в същото хранилище.
Единствената разлика е, че в клоновете на fork-натите хранилища нормално нямате достъп за писане (а и собствениците им нямат към вашите клонове), докато при вътрешните Pull Request-и обикновено и двете страни могат да пишат в клона.

За тези примери, нека приемем, че вие сте потребител ``tonychacon'' и сте създали нов Arduino проект наречен ``fade''.

[[_email_notifications]]
===== Email известяване

Някой се появява, променя част от кода ви и ви изпраща Pull Request.
Ще получите електронна поща за новия Pull Request изглеждащ подобно на <<_email_pr>>.

[[_email_pr]]
.Email известяване за нов Pull Request.
image::images/maint-01-email.png[Email известяване за нов Pull Request]

Няколко неща са за отбелязване в този имейл.
Първо, той съдържа малък diffstat -- списък на файловете, в които има промени от Pull Request-а и в какво количество са те.
След това, имате линк към Pull Request-а в GitHub.
Предоставят ви се и няколко URL-а, които можете да ползвате от командния ред.

Ако виждате ред `git pull <url> patch-1`, това е прост начин да слеете отдалечен клон без да трябва да добавяте remote.
Видяхме това в <<_distributed_git#_checking_out_remotes>>.
Ако искате, можете да създадете и да превключите в topic клон и след това да изпълните тази команда за да слеете Pull Request-а.

Другите интересни URL-и са `.diff` и `.patch` URL-ите, които както можете да предположите, осигуряват unified diff и patch версии на Pull Request-а.
Технически, можете да слеете работата в Pull Request-а примерно така:

[source,console]
----
$ curl http://github.com/tonychacon/fade/pull/1.patch | git am
----

===== Съвместна работа по Pull Request

Както видяхме в <<_github#_github_flow>>, сега можете да проведете дискусия с човека, който е пуснал Pull Request-а.
Можете да коментирате специфични редове код, да коментирате цели къмити или целия Pull Request, използвайки GitHub Flavored Markdown където искате.

Всеки път, когато някой друг коментира Pull Request-а, ще продължавате да получавате имейл нотификации, така че да сте наясно какво се случва.
Всеки от дискутиращите ще има линк към Pull Request-а и също така можете директно да отговорите на имейла пускайки автоматично коментар в Pull Request нишката в GitHub.


.Отговорите на имейлите се показват в нишката.
image::images/maint-03-email-resp.png[Отговор по Email]

Веднъж след като кодът е одобрен и искате да го слеете, можете или да го издърпате и слеете локално с помощта на `git pull <url> <branch>` синтаксиса, който видяхме по-рано, или да добавите fork-хранилището като remote, даго изтеглите и слеете.

Ако сливането е просто, можете направо да натиснете бутона ``Merge'' в GitHub.
Това ще направи ``non-fast-forward'' сливане с merge commit, дори и ако е възможно fast-forward сливане.
Всеки път когато използвате бутона, винаги се създава merge commit независимо от обстоятелствата.
Както можете да видите в <<_merge_button>>, GitHub ви дава цялата тази информация ако натиснете помощната препратка.

[[_merge_button]]
.Merge бутон и инструкции за сливането на Pull Request-а ръчно.
image::images/maint-02-merge.png[Merge бутон]

Ако решите, че не искате да слеете, можете просто да затворите Pull Request-а и човекът, който го е стартирал ще бъде уведомен.

[[_pr_refs]]
===== Pull Request референции

Ако си имате работа с *много* Pull Request-и и не искате да добавяте цял куп remotes или да правите еднократни изтегляния всеки път, GitHub ви предоставя един хитър трик за улеснение в работата.
Това е материал за напреднали и ще видим детайлите за него в <<_git_internals#_refspec>>, но може да е много полезен.

GitHub в действителност представя Pull Request клоновете за дадено хранилище като вид псевдо-клонове на сървъра.
По подразбиране, вие не ги получавате при клониране, но те са там по един маскиран начин и можете да получите достъп до тях лесно.

За да демонстрираме това, ще използваме low-level команда (често наричана ``plumbing'' команда, за която ще научим повече в <<_git_internals#_plumbing_porcelain>>) наречена `ls-remote`.
Обикновено тази команда не се използва ежедневно в Git операциите, но е полезна защото ни показва какви референции съществуват на сървъра.

Ако стартираме тази команда за ``blink'' хранилището, което ползвахме по-рано, ще видим списък от всички клонове, тагове и други референции в него.

[source,console]
----
$ git ls-remote https://github.com/schacon/blink
10d539600d86723087810ec636870a504f4fee4d	HEAD
10d539600d86723087810ec636870a504f4fee4d	refs/heads/master
6a83107c62950be9453aac297bb0193fd743cd6e	refs/pull/1/head
afe83c2d1a70674c9505cc1d8b7d380d5e076ed3	refs/pull/1/merge
3c8d735ee16296c242be7a9742ebfbc2665adec1	refs/pull/2/head
15c9f4f80973a2758462ab2066b6ad9fe8dcf03d	refs/pull/2/merge
a5a7751a33b7e86c5e9bb07b26001bb17d775d1a	refs/pull/4/head
31a45fc257e8433c8d8804e3e848cf61c9d3166c	refs/pull/4/merge
----

Разбира се, ако сте във вашето хранилище и изпълните `git ls-remote origin` или кой да е друг remote, ще видите отпечатан изход подобен на този.

Ако хранилището е в GitHub и имате отворени Pull Request-и, ще получите тези референции с префикс `refs/pull/`.
Това по същество са клонове, но понеже не са под `refs/heads/`, нормално не ги получавате когато клонирате или изтегляте от сървъра -- fetching процесът по подразбиране ги игнорира.

Има по две референции на Pull Request - едната която завършва на `/head` сочи към точно същия къмит както и последния къмит в Pull Request клона.
По този начин, ако някой отвори Pull Request в наше хранилище и клонът му се казва `bug-fix`, сочещ към къмит `a5a775`, тогава в *нашето* хранилище ние няма да имаме `bug-fix` клон (той е във fork-а), но _ще имаме_ `pull/<pr#>/head` референция сочеща към `a5a775`.
Това означава, че можем лесно да изтеглим всеки Pull Request клон в една стъпка без да трябва да добавяме множество remotes.

Сега можем да изтеглим референцията директно.

[source,console]
----
$ git fetch origin refs/pull/958/head
From https://github.com/libgit2/libgit2
 * branch            refs/pull/958/head -> FETCH_HEAD
----

Това инструктира Git да се свържи с `origin` адреса и да изтегли референцията наречена `refs/pull/958/head`.
Git за щастие следва инструкцията и сваля всичко необходимо за конструирането на тази референция, след което поставя указател към къмита, който искате в `.git/FETCH_HEAD`.
Можете да продължите с `git merge FETCH_HEAD` в клон, в който да тествате, но merge commit съобщението изглежда леко странно.
Също така, ако разглеждате *много* Pull Request-и, тоеа става досадно

Съществува също начин да изтеглите _всички_ Pull Request-и и да ги актуализирате всеки път, когато се свързвате с отдалечения сървър.
Отворете файла `.git/config` и потърсете `origin` секцията.
Ще изглежда по подобен начин:

[source,ini]
----
[remote "origin"]
    url = https://github.com/libgit2/libgit2
    fetch = +refs/heads/*:refs/remotes/origin/*
----

Редът , който започва с `fetch =` се нарича ``refspec.''
Това е начин за съотнасяне на имена в сървъра с имена в локалната ви `.git` директория.
В примера тук, това казва на Git, "нещата на сървъра, които се намират в `refs/heads` трябва да се съхраняват в локалното ми хранилище в `refs/remotes/origin`."
Можете да промените тази секция за да добавите друг refspec:

[source,ini]
----
[remote "origin"]
    url = https://github.com/libgit2/libgit2.git
    fetch = +refs/heads/*:refs/remotes/origin/*
    fetch = +refs/pull/*/head:refs/remotes/origin/pr/*
----

Това инструктира Git че, ``всички refs изглеждащи като `refs/pull/123/head` трябва да се съхраняват локално като `refs/remotes/origin/pr/123`.''
Сега, ако запишете файла и изпълните `git fetch`:

[source,console]
----
$ git fetch
# …
 * [new ref]         refs/pull/1/head -> origin/pr/1
 * [new ref]         refs/pull/2/head -> origin/pr/2
 * [new ref]         refs/pull/4/head -> origin/pr/4
# …
----

Сега всички отдалечени Pull Request-и се представят локално като refs, които работят като tracking клонове - те са само за четене и се обновяват когато теглите.
Това прави много лесно изпробването на код от Pull Request локално:

[source,console]
----
$ git checkout pr/2
Checking out files: 100% (3769/3769), done.
Branch pr/2 set up to track remote branch pr/2 from origin.
Switched to a new branch 'pr/2'
----

The eagle-eyed among you would note the `head` on the end of the remote portion of the refspec.
There's also a `refs/pull/#/merge` ref on the GitHub side, which represents the commit that would result if you push the ``merge'' button on the site.
This can allow you to test the merge before even hitting the button.


===== Pull Requests on Pull Requests

Not only can you open Pull Requests that target the main or `master` branch, you can actually open a Pull Request targeting any branch in the network.
In fact, you can even target another Pull Request.

If you see a Pull Request that is moving in the right direction and you have an idea for a change that depends on it or you're not sure is a good idea, or you just don't have push access to the target branch, you can open a Pull Request directly to it.

When you go to open a Pull Request, there is a box at the top of the page that specifies which branch you're requesting to pull to and which you're requesting to pull from.
If you hit the ``Edit'' button at the right of that box you can change not only the branches but also which fork.

[[_pr_targets]]
.Manually change the Pull Request target fork and branch.
image::images/maint-04-target.png[PR targets]

Here you can fairly easily specify to merge your new branch into another Pull Request or another fork of the project.

==== Mentions and Notifications

GitHub also has a pretty nice notifications system built in that can come in handy when you have questions or need feedback from specific individuals or teams.

In any comment you can start typing a `@` character and it will begin to autocomplete with the names and usernames of people who are collaborators or contributors in the project.

.Start typing @ to mention someone.
image::images/maint-05-mentions.png[Mentions]

You can also mention a user who is not in that dropdown, but often the autocompleter can make it faster.

Once you post a comment with a user mention, that user will be notified.
This means that this can be a really effective way of pulling people into conversations rather than making them poll.
Very often in  Pull Requests on GitHub people will pull in other people on their teams or in their company to review an Issue or Pull Request.

If someone gets mentioned on a Pull Request or Issue, they will be ``subscribed'' to it and will continue getting notifications any time some activity occurs on it.
You will also be subscribed to something if you opened it, if you're watching the repository or if you comment on something.
If you no longer wish to receive notifications, there is an ``Unsubscribe'' button on the page you can click to stop receiving updates on it.

.Unsubscribe from an Issue or Pull Request.
image::images/maint-06-unsubscribe.png[Unsubscribe]

===== The Notifications Page

When we mention ``notifications'' here with respect to GitHub, we mean a specific way that GitHub tries to get in touch with you when events happen and there are a few different ways you can configure them.
If you go to the ``Notification center'' tab from the settings page, you can see some of the options you have.

.Notification center options.
image::images/maint-07-notifications.png[Notification center]

The two choices are to get notifications over ``Email'' and over ``Web'' and you can choose either, neither or both for when you actively participate in things and for activity on repositories you are watching.

====== Web Notifications

Web notifications only exist on GitHub and you can only check them on GitHub.
If you have this option selected in your preferences and a notification is triggered for you, you will see a small blue dot over your notifications icon at the top of your screen as seen in <<_not_center>>.

[[_not_center]]
.Notification center.
image::images/maint-08-notifications-page.png[Notification center]

If you click on that, you will see a list of all the items you have been notified about, grouped by project.
You can filter to the notifications of a specific project by clicking on its name in the left hand sidebar.
You can also acknowledge the notification by clicking the checkmark icon next to any notification, or acknowledge _all_ of the notifications in a project by clicking the checkmark at the top of the group.
There is also a mute button next to each checkmark that you can click to not receive any further notifications on that item.

All of these tools are very useful for handling large numbers of notifications.
Many GitHub power users will simply turn off email notifications entirely and manage all of their notifications through this screen.

====== Email Notifications

Email notifications are the other way you can handle notifications through GitHub.
If you have this turned on you will get emails for each notification.
We saw examples of this in <<_email_notification>> and <<_email_pr>>.
The emails will also be threaded properly, which is nice if you're using a threading email client.

There is also a fair amount of metadata embedded in the headers of the emails that GitHub sends you, which can be really helpful for setting up custom filters and rules.

For instance, if we look at the actual email headers sent to Tony in the email shown in <<_email_pr>>, we will see the following among the information sent:

[source,mbox]
----
To: tonychacon/fade <fade@noreply.github.com>
Message-ID: <tonychacon/fade/pull/1@github.com>
Subject: [fade] Wait longer to see the dimming effect better (#1)
X-GitHub-Recipient: tonychacon
List-ID: tonychacon/fade <fade.tonychacon.github.com>
List-Archive: https://github.com/tonychacon/fade
List-Post: <mailto:reply+i-4XXX@reply.github.com>
List-Unsubscribe: <mailto:unsub+i-XXX@reply.github.com>,...
X-GitHub-Recipient-Address: tchacon@example.com
----

There are a couple of interesting things here.
If you want to highlight or re-route emails to this particular project or even Pull Request, the information in `Message-ID` gives you all the data in `<user>/<project>/<type>/<id>` format.
If this were an issue, for example, the `<type>` field would have been ``issues'' rather than ``pull''.

The `List-Post` and `List-Unsubscribe` fields mean that if you have a mail client that understands those, you can easily post to the list or ``Unsubscribe'' from the thread.
That would be essentially the same as clicking the ``mute'' button on the web version of the notification or ``Unsubscribe'' on the Issue or Pull Request page itself.

It's also worth noting that if you have both email and web notifications enabled and you read the email version of the notification, the web version will be marked as read as well if you have images allowed in your mail client.

==== Special Files

There are a couple of special files that GitHub will notice if they are present in your repository.

==== README

The first is the `README` file, which can be of nearly any format that GitHub recognizes as prose.
For example, it could be `README`, `README.md`, `README.asciidoc`, etc.
If GitHub sees a README file in your source, it will render it on the landing page of the project.

Many teams use this file to hold all the relevant project information for someone who might be new to the repository or project.
This generally includes things like:

* What the project is for
* How to configure and install it
* An example of how to use it or get it running
* The license that the project is offered under
* How to contribute to it

Since GitHub will render this file, you can embed images or links in it for added ease of understanding.

==== CONTRIBUTING

The other special file that GitHub recognizes is the `CONTRIBUTING` file.
If you have a file named `CONTRIBUTING` with any file extension, GitHub will show <<_contrib_file>> when anyone starts opening a Pull Request.

[[_contrib_file]]
.Opening a Pull Request when a CONTRIBUTING file exists.
image::images/maint-09-contrib.png[Contributing notice]

The idea here is that you can specify specific things you want or don't want in a Pull Request sent to your project.
This way people may actually read the guidelines before opening the Pull Request.

==== Project Administration

Generally there are not a lot of administrative things you can do with a single project, but there are a couple of items that might be of interest.

===== Changing the Default Branch

If you are using a branch other than ``master'' as your default branch that you want people to open Pull Requests on or see by default, you can change that in your repository's settings page under the ``Options'' tab.

[[_default_branch]]
.Change the default branch for a project.
image::images/maint-10-default-branch.png[Default branch]

Simply change the default branch in the dropdown and that will be the default for all major operations from then on, including which branch is checked out by default when someone clones the repository.

===== Transferring a Project

If you would like to transfer a project to another user or an organization in GitHub, there is a ``Transfer ownership'' option at the bottom of the same ``Options'' tab of your repository settings page that allows you to do this.

[[_transfer_project]]
.Transfer a project to another GitHub user or Organization.
image::images/maint-11-transfer.png[Transfer]

This is helpful if you are abandoning a project and someone wants to take it over, or if your project is getting bigger and want to move it into an organization.

Not only does this move the repository along with all its watchers and stars to another place, it also sets up a redirect from your URL to the new place.
It will also redirect clones and fetches from Git, not just web requests.
