[[_git_reset]]
=== Да разбулим мистерията на Reset

Преди да преминем към по-специализираните инструменти на Git, нека поговорим още малко за `reset` и `checkout` командите.
Тези команди са два от най-смущаващите аспекти в Git, когато за първи път се сблъскате с тях.
Правят толкова много неща, че изглежда безнадеждно да бъдат разбрани и използвани ефективно.
Ето защо, препоръчваме проста метафора.

==== Трите дървета

Един по-лесен подход да мислите за `reset` и `checkout` е да гледате на Git като мениджър на съдържание за три различни дървета.
Като казваме ``дърво'', в действителност разбираме ``колекция от файлове'', а не структурата от данни.  
 (Има няколко ситуации, където индексът на практика не работи като дърво, но за нашите цели е по-лесно да го възприемаме като такова.)

Git като система управлява три дървета в нормалната си работа:

[cols="1,2",options="header"]
|================================
| Дърво              | Роля
| HEAD              | Snapshot на последния къмит, родител на следващия
| Index             | Snapshot за следващия къмит
| Работна директория | Работна област
|================================

===== Дървото HEAD

HEAD е указателят към референцията на текущия клон, която от своя страна сочи към последния къмит направен в този клон.
Това означава, че HEAD ще бъде родител на следващия създаден къмит.
Най-лесно е да гледаме на HEAD като на snapshot на *последния ни къмит в този клон*.

В действителност, лесно е да видим как изглежда този snapshot.
Ето пример за извличане на реалния листинг на директория и SHA-1 чексумите за всеки файл в HEAD snapshot-а:

[source,console]
----
$ git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

$ git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib
----

Командите на Git `cat-file` и `ls-tree` са ``plumbing'' команди използвани за неща на по-ниско ниво и рядко се използват в ежедневната работа, но ни помагат да видим какво се случва тук.

[[_the_index]]
===== Индексът

Индексът е *очаквания следващ къмит *.
Наричаме го още ``Staging Area'' понеже това е мястото, от което Git взема данни когато изпълните `git commit`.

Git попълва индекса със списък от съдържанието на всички файлове, които последно са били извлечени в работната директория и как са изглеждали те когато първоначално са били извлечени.
Вие след това замествате част от файловете с техни актуализирани версии и `git commit` конвертира това в дървото за нов къмит.

[source,console]
----
$ git ls-files -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README
100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb
----

Отново, тук използваме `git ls-files`, която е задкулисна команда, показаща ви как изглежда текущия ви индекс.

Технически, индексът не е дървовидна структура -- реално той е имплементиран като плосък манифест -- но за нашите цели можем да кажем, че прилича на дърво.

===== Работната директория

Накрая идва третото Git дърво, работната ви директория.
Другите две съхраняват съдържанието си в ефективен, но неудобен маниер, в директорията `.git`.
Работната директория, от своя страна, го разпакетира в действителните файлове, с които работим.
Можем да гледаме на нея като на *опитно поле*, в което пробваме промените си преди да ги изпратим в индексната област и след това в историята.

[source,console]
----
$ tree
.
├── README
├── Rakefile
└── lib
    └── simplegit.rb

1 directory, 3 files
----

==== Работният процес

Основната работа на Git е да записва snapshot-и на проекта ни в последователни серии, манипулирайки тези три дървета.

image::images/reset-workflow.png[]

Нека онгаледим процеса: да кажем, че отиваме в нова директория с един файл в нея.
Ще наречем това *v1* на файла и ще го маркираме в синьо.
Сега изпълняваме `git init`, което ще създаде ново Git хранилище с HEAD референция, която сочи към все още несъществуващ клон (`master` все още не е създаден).

image::images/reset-ex1.png[]

На този етап, единствено работната ни директория има някакво съдържание.

Сега ще искаме да индексираме този файл, така че изпозлваме `git add` за да вземем съдържанието от работната област и да го копираме в индексната.

image::images/reset-ex2.png[]

След това, изпълняваме `git commit`, което ще вземе съдържанието на индекса и ще го запише като перманентен snapshot, ще създаде къмит обект, който сочи към този snapshot и ще настрои нашия `master` клон да сочи към този къмит.

image::images/reset-ex3.png[]

Ако сега изпълним `git status`, няма да видим промени, защото трите ни дървета са идентични.

Сега правим промяна по файла и го къмитваме.
Ще минем през същия процес, първо променяме файла в работната директория.
Нека наречем това *v2* на файла и да го маркираме в червено.

image::images/reset-ex4.png[]

Когато изпълним `git status` в този момент, ще видим този файл в червено в секцията ``Changes not staged for commit,'' защото той сега се различава от копието си в индекса.
След това изпълняваме `git add` и го индексираме.

image::images/reset-ex5.png[]

В момента, `git status`, ще ни покаже файла в зелен цвят в секцията ``Changes to be committed'' защото индексът и HEAD се различават -- тоест нашият очаквам следващ къмит е различен от последно съхрания.
Последно, изпълняваме `git commit` за да финализираме нови къмит.

image::images/reset-ex6.png[]

Сега `git status` няма да покаже разлики, защото трите дървета отново са еднакви.

Клонирането и превключването на клонове минават през подобен процес.
Когато превключим към друг клон, *HEAD* се променя и сочи към референцията на този клон, *индексът* се попълва със snapshot-а на този къмит и след това съдържанието на *индекса* се копира в *работната директория*.

==== Ролята на Reset

Командата`reset` придобива по-ясно значение, когато се разглежда в такъв контекст.

За целта на тези примери, нека кажем, че сме променили `file.txt` отново и сме го къмитнали за трети път.
Така историята ни сега ще изглежда по този начин:

image::images/reset-start.png[]

Нека минем през това какво точно прави `reset`, когато я изпълним.
Тя директно манипулира тези три дървета по прост и предвидим начин.
Извършват се три основни операции.

===== Стъпка 1: Преместване на HEAD

Първото нещо, което `reset` прави е да смени мястото, където HEAD сочи.
Това не означава, че самия HEAD се променя (което става с `checkout`), `reset` премества клона, към който сочи HEAD.
Което ще рече, че ако HEAD е на `master` клона (тоест в момента сте в този клон), изпълнението на `git reset 9e5e6a4` ще започне като направи `master` да сочи към `9e5e6a4`.

image::images/reset-soft.png[]

Без значение каква форма на `reset` с къмит сте изпълнили, това е първото нещо, което командата винагои ще опита да направи.
С `reset --soft`, тя просто ще завърши тук.

Сега погледнете пак последната диаграма и ще видите какво се е случило: командата практически е отменила последно изпълнената `git commit` команда.
Когато изпълните `git commit`, Git създава нов къмит и премества клона, към който сочи HEAD към този къмит.
Когато ресетнете обратно към `HEAD~` (тоест родителя на HEAD), вие премествате клона обратно където е бил без да променяте индекса или работната директория.
Сега можете да обновите индекса и да изпълните `git commit` отново, така че да постигнете резултата, който бихте имали с `git commit --amend` (вижте <<_git_amend>>).

===== Стъпка 2: Обновяване на индекса (--mixed)

Ако сега пуснете `git status`, ще видите в зелено разликата между индекса и новия HEAD.

Следващото нещо, което `reset` ще направи е да обнови индекса със съдържанието на snapshot-а, към който вече сочи HEAD.

image::images/reset-mixed.png[]

Ако подадете аргумента `--mixed`, `reset` ще спре процеса в тази точка.
This is also the default, so if you specify no option at all (just `git reset HEAD~` in this case), this is where the command will stop.

Now take another second to look at that diagram and realize what happened: it still undid your last `commit`, but also _unstaged_ everything.
You rolled back to before you ran all your `git add` and `git commit` commands.

===== Step 3: Updating the Working Directory (--hard)

The third thing that `reset` will do is to make the Working Directory look like the Index.
If you use the `--hard` option, it will continue to this stage.

image::images/reset-hard.png[]

So let's think about what just happened.
You undid your last commit, the `git add` and `git commit` commands, *and* all the work you did in your working directory.

It's important to note that this flag (`--hard`) is the only way to make the `reset` command dangerous, and one of the very few cases where Git will actually destroy data.
Any other invocation of `reset` can be pretty easily undone, but the `--hard` option cannot, since it forcibly overwrites files in the Working Directory.
In this particular case, we still have the *v3* version of our file in a commit in our Git DB, and we could get it back by looking at our `reflog`, but if we had not committed it, Git still would have overwritten the file and it would be unrecoverable.

===== Recap

The `reset` command overwrites these three trees in a specific order, stopping when you tell it to:

1. Move the branch HEAD points to _(stop here if `--soft`)_
2. Make the Index look like HEAD _(stop here unless `--hard`)_
3. Make the Working Directory look like the Index

==== Reset With a Path

That covers the behavior of `reset` in its basic form, but you can also provide it with a path to act upon.
If you specify a path, `reset` will skip step 1, and limit the remainder of its actions to a specific file or set of files.
This actually sort of makes sense -- HEAD is just a pointer, and you can't point to part of one commit and part of another.
But the Index and Working directory _can_ be partially updated, so reset proceeds with steps 2 and 3.

So, assume we run `git reset file.txt`.
This form (since you did not specify a commit SHA-1 or branch, and you didn't specify `--soft` or `--hard`) is shorthand for `git reset --mixed HEAD file.txt`, which will:

1. Move the branch HEAD points to _(skipped)_
2. Make the Index look like HEAD _(stop here)_

So it essentially just copies `file.txt` from HEAD to the Index.

image::images/reset-path1.png[]

This has the practical effect of _unstaging_ the file.
If we look at the diagram for that command and think about what `git add` does, they are exact opposites.

image::images/reset-path2.png[]

This is why the output of the `git status` command suggests that you run this to unstage a file.
(See <<ch02-git-basics-chapter#_unstaging>> for more on this.)

We could just as easily not let Git assume we meant ``pull the data from HEAD'' by specifying a specific commit to pull that file version from.
We would just run something like `git reset eb43bf file.txt`.

image::images/reset-path3.png[]

This effectively does the same thing as if we had reverted the content of the file to *v1* in the Working Directory, ran `git add` on it, then reverted it back to *v3* again (without actually going through all those steps).
If we run `git commit` now, it will record a change that reverts that file back to *v1*, even though we never actually had it in our Working Directory again.

It's also interesting to note that like `git add`, the `reset` command will accept a `--patch` option to unstage content on a hunk-by-hunk basis.
So you can selectively unstage or revert content.

==== Squashing

Let's look at how to do something interesting with this newfound power -- squashing commits.

Say you have a series of commits with messages like ``oops.'', ``WIP'' and ``forgot this file''.
You can use `reset` to quickly and easily squash them into a single commit that makes you look really smart.
(<<_squashing>> shows another way to do this, but in this example it's simpler to use `reset`.)

Let's say you have a project where the first commit has one file, the second commit added a new file and changed the first, and the third commit changed the first file again.
The second commit was a work in progress and you want to squash it down.

image::images/reset-squash-r1.png[]

You can run `git reset --soft HEAD~2` to move the HEAD branch back to an older commit (the most recent commit you want to keep):

image::images/reset-squash-r2.png[]

And then simply run `git commit` again:

image::images/reset-squash-r3.png[]

Now you can see that your reachable history, the history you would push, now looks like you had one commit with `file-a.txt` v1, then a second that both modified `file-a.txt` to v3 and added `file-b.txt`.
The commit with the v2 version of the file is no longer in the history.

==== Check It Out

Finally, you may wonder what the difference between `checkout` and `reset` is.
Like `reset`, `checkout` manipulates the three trees, and it is a bit different depending on whether you give the command a file path or not.

===== Without Paths

Running `git checkout [branch]` is pretty similar to running `git reset --hard [branch]` in that it updates all three trees for you to look like `[branch]`, but there are two important differences.

First, unlike `reset --hard`, `checkout` is working-directory safe; it will check to make sure it's not blowing away files that have changes to them.
Actually, it's a bit smarter than that -- it tries to do a trivial merge in the Working Directory, so all of the files you _haven't_ changed will be updated.
`reset --hard`, on the other hand, will simply replace everything across the board without checking.

The second important difference is how `checkout` updates HEAD.
Whereas `reset` will move the branch that HEAD points to, `checkout` will move HEAD itself to point to another branch.

For instance, say we have `master` and `develop` branches which point at different commits, and we're currently on `develop` (so HEAD points to it).
If we run `git reset master`, `develop` itself will now point to the same commit that `master` does.
If we instead run `git checkout master`, `develop` does not move, HEAD itself does.
HEAD will now point to `master`.

So, in both cases we're moving HEAD to point to commit A, but _how_ we do so is very different.
`reset` will move the branch HEAD points to, `checkout` moves HEAD itself.

image::images/reset-checkout.png[]

===== With Paths

The other way to run `checkout` is with a file path, which, like `reset`, does not move HEAD.
It is just like `git reset [branch] file` in that it updates the index with that file at that commit, but it also overwrites the file in the working directory.
It would be exactly like `git reset --hard [branch] file` (if `reset` would let you run that) -- it's not working-directory safe, and it does not move HEAD.

Also, like `git reset` and `git add`, `checkout` will accept a `--patch` option to allow you to selectively revert file contents on a hunk-by-hunk basis.

==== Summary

Hopefully now you understand and feel more comfortable with the `reset` command, but are probably still a little confused about how exactly it differs from `checkout` and could not possibly remember all the rules of the different invocations.

Here's a cheat-sheet for which commands affect which trees.
The ``HEAD'' column reads ``REF'' if that command moves the reference (branch) that HEAD points to, and ``HEAD'' if it moves HEAD itself.
Pay especial attention to the 'WD Safe?' column -- if it says *NO*, take a second to think before running that command.

[options="header", cols="3,1,1,1,1"]
|================================
| | HEAD | Index | Workdir | WD Safe?
| *Commit Level* | | | |
| `reset --soft [commit]` | REF | NO | NO | YES
| `reset [commit]` | REF | YES | NO | YES
| `reset --hard [commit]` | REF | YES | YES | *NO*
| `checkout <commit>` | HEAD | YES | YES | YES
| *File Level* | | | |
| `reset [commit] <paths>` | NO | YES | NO | YES
| `checkout [commit] <paths>` | NO | YES | YES | *NO*
|================================
