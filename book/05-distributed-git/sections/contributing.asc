[[_contributing_project]]
=== Как да сътрудничим в проект

(((contributing)))
Основната трудност с обяснението на това как се допринася към проект са големия брой варианти как да го направите.
Понеже Git е много гъвкав, хората могат (и го правят) да си вършат работата по различни начини – затова е проблематично да се даде съвет как да постъпите – всеки проект си има специфики.
Сред факторите, които влияят са броя разработчици, избрания вид работен процес, вашите права за достъп до хранилището и вероятно външния метод за съвместна работа.

Първата неизвестна е броят разработчици – колко са много активните колеги и колко често сътрудничат?
В много случаи ще имате двама или трима програмисти с малко къмити на ден, или дори и по-малко при малко интензивни проекти.
В големи компании или проекти обаче, могат да съществуват хиляди сътрудници със стотици или хиляди къмити на ден.
Това е важно, защото с увеличаването на броя програмисити, ще срещате повече проблеми с това да се уверите, че кодът се прилага чисто или може лесно да се слива.
Промените, които предлагате могат да се окажат остарели или несъвместими с друга работа, която е била слята докато сте работили или докато сте чакали вашия код да бъде одобрен.
Възниква въпроса как да поддържате кода си актуален и къмитите си валидни?

Следващият фактор е избраният вид работен процес.
Дали той е централизиран, при който всеки разработчик има еднакъв достъп за писане до основното хранилище?
Длаи проектът има поддържащ потребител или интегриращ мениджър, които да проверяват всички пачове?
Дали всички пачове се разглеждат и одобряват колективно?
Дали вие участвате в този процес?
Съществува ли lieutenant-система и трябва ли първо да изпращате работата си на вашия лейтенант?

Следват правата ви на достъп.
Последователността на работа, когато трябва да участвате в проект е доста различна в зависимост от това дали имате права за писане или не.
Ако нямате права за писане, как този проект предпочита да приема външна помощ?
Дали въобще съществува политика за това?
Какво количество работа изпращате всеки път?
Колко често правите това?

Всички тези въпроси могат да се отразят на начина, по който вие допринасяте към дадне проект и какви работни процеси са предпочитани или достъпни за вас.
Ще разгледаме различните аспекти в серия от примери, започвайки от прости към по-сложни и в края би следвало да си изградите представа какъв похват ще ви е необходим в различните случаи от реалната практика.

[[_commit_guidelines]]
==== Упътвания за къмитване

Преди да се фокусираме върху конкретни примери, едно малко отклонение касаещо къмит съобщенията.
Да имате добра насока за създаване на къмити и да се пирдържате към нея ще направи работата ви с Git и сътрудничеството с колегите много по-лесни.
Самият проект Git предоставя документ формулиращ множество добри съвети за създаване на къмити, от които да изпращате пачове -- можете да го прочетете в сорс кода на Git, във файла Documentation/SubmittingPatches`.

(((git commands, diff, check)))
Първо, вашите промени не трябва да съдържат никакви whitespace грешки.
Git осигурява лесен начин да проверите това – преди да къмитнете, изпълнете командата `git diff --check`, която намира възможните whitespace грешки и ви ги показва.

.Изход от `git diff --check`.
image::images/git-diff-check.png[Изход от `git diff --check`.]

Ако я изпълните преди да къмитнете, можете да разберете дали не вкарвате в проекта излишни интервали, които да отегчат останалите ви колеги.

След това, опитайте се да направите всеки един къмит логически отделена, самостоятелна и специфична за даден проблем промяна.
Ако можете, опитайте да правите промените си по-компактни – не програмирайте цял уикенд по пет различни задачи и после да ги изпращате като един масивен къмит в понеделник.
Дори ако през уикенда не сте къмитвали, използвайте индексната област в понеделник за да разделите работата си на няколко къмита, всеки от които обслужва конкретен решен проблем и съдържа съответното подходящо съобщение.
Ако някои от промените засягат един и същи файл, опитайте да използвате `git add --patch` за да индексирате файловете частично (показано в подробности в <<_interactive_staging>>).
В края на краищата, snapshot-тът на края на клона ви ще е идентичен независимо дали сте направили един или пет къмита, така че пробвайте да улените живота на вашите колеги, когато започнат да разглеждат работата ви.

Този подход също така ви позволява по-късно да премахнете или коригирате само част от промените си, ако се наложи.
<<_rewriting_history>> описва няколко полезни Git трика за презапис на историята и интерактивно индексиране на файлове -- използвайте тези инструменти като помощ за поддържане на чиста и разбираема история преди да изпратите работата си към някой друг.

Последното нещо, което трябва да не се пренебрегва е къмит съобщението.
Изработете си навик да създавате качествени къмит съобщения и ще работите с Git и колегите си много по-приятно.
Като основно правило, съобщенията ви трябва да започват с един ред не по-дълъг от 50 символа, описващ стегнато промените, следван от празен ред, след което може да се разположат по-дългите обяснения.
Git проектът например изисква подробното описание да включва мотивите ви за дадената промяна и да обяснява разликите с оригиналния вариант на кода – и това е добро правило, което може да следвате.
Добра идея също е да използвате сегашно време и повелителен стил в съобщенията.
С други думи, използвайте команди.
Вместо ``I added tests for'' или ``Adding tests for,'' използвайте ``Add tests for.''
Тук има един http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html[шаблон, написан отначало от Tim Pope]:

[source,text]
----
Кратко (50 или по-малко символа) описание на промените

По-детайлно описание, ако е нужно.  Пренасяйте го
на около 72 символа.  В някои случаи, първият
ред се третира като subject на email и останалото
от текста като тяло.  Празният ред разделящ двете
е много важен (освен ако не пропускате тялото
изцяло);инструменти като rebase може да се объркат
ако пуснете двете заедно.

Слеващите абзаци се разделят с празни редове.

  - точките (Bullet) също са ОК

  - Обикновено за точка се използва звездичка или тире,
    Предшествано от един интервал, с празни редове
    помежду им, но правилата тук варират
----

Ако всички ваши къмит съобщения следват този модел, нещата между вас и колегите ви разработчици ще вървят по-гладко.
Git проектът има добре форматирани къмит съобщения -- пробвайте да пуснете `git log --no-merges` в хранилището и ще видите колко добре форматирана е историята на проекта.

[NOTE]
.Правете каквото казваме, а не каквото правим.
====
Много от примерите в тази книга съвсем не съдържат добре форматирани къмит съобщения; ние използваме `-m` параметъра към `git commit` за по-кратко.

Накракто, следвайте правилото за добра практика, а не гледайте какво сме направили ние.
====

[[_private_team]]
==== Малък частен екип

(((contributing, private small team)))
Най-простата схема, на която може да попаднете е частен проект с един или двама разработчици.
``Частен,'' в този смисъл, означава със затворен код -- недостъпен за външния свят.
Вие всички имате достъп за писане до хранилището.

В такава среда, можете да следвате работен процес подобен на този, който бихте ползвали в Subversion или друга централизирана система.
Може все още да използвате предимствата на неща като офлайн къмитване и съвсем прости разклонявания и сливания, но работният процес може да е много подобен; основната разлика е, че сливанията се случват от страна на клиента, вместо на сървъра по време на къмита.
Нека видим как би могло да изглежда това когато двама разработчика започнат съвместна работа със споделено хранилище.
Първият програмист, John, клонира хранилището, прави промяна и къмитва локално.
(Протоколните съобщения са заменени с `...` в тези примери за да ги съкратим.)

[source,console]
----
# John's Machine
$ git clone john@githost:simplegit.git
Cloning into 'simplegit'...
...
$ cd simplegit/
$ vim lib/simplegit.rb
$ git commit -am 'remove invalid default value'
[master 738ee87] remove invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)
----

Вторият разработчик, Jessica, прави същото нещо -- клонира хранилището и къмитва промяна:

[source,console]
----
# Jessica's Machine
$ git clone jessica@githost:simplegit.git
Cloning into 'simplegit'...
...
$ cd simplegit/
$ vim TODO
$ git commit -am 'add reset task'
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)
----

Сега, Jessica публикува работата си на сървъра и това работи безпроблемно:

[source,console]
----
# Jessica's Machine
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -> master
----

Последният ред от изхода отгоре показва полезно съобщение за резултата от push операцията.
Основният формат е `<oldref>..<newref> fromref -> toref`, където `oldref` означава референция към предишния къмит, `newref` - към текущия, `fromref` е името на локалния клон, който се изпраща, и `toref` - на отдалечения, който се обновява.
Ще виждате подобен изход по-натам в дискусиите, така че да имате представа какво означава това ще е полезно в осмислянето на различните статуси на хранилищата.

Повече подробности има в документацията на командата https://git-scm.com/docs/git-push[git-push].

Продължаваме с този пример. Скоро след това, John прави някакви промени, къмитва ги в локалното си хранилище и се опитва да ги изпрати в същия сървър:

[source,console]
----
# John's Machine
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -> master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'
----

В този случай, опитът му завършва с неуспех, защото Jessica е изпратила _нейните_ промени по-рано.
Това е особено важно да се разбере, ако сте ползвали Subversion, защото вероятно забелязвате, че двамата разработчици не са редактирали един и същи файл.
Въпреки че Subversion ще направи автоматично сливане на сървъра в случаи като този (променени различни файлове), при Git, вие трябва _първо_ да слеете къмитите локално.
С други думи, John трябва първо да изтегли upstream промените на Jessica, да ги слее в локалното си хранилище и едва след това ще може да изпраща към сървъра.

Като първа стъпка, John изтегля работата на Jessica (командата отдолу само _изтегля_ последната работа на Jessica, не я слива автоматично):

[source,console]
----
$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -> origin/master
----

В този момент, локалното хранилище на John изглежда подобно на това:

.Разклонена история на John.
image::images/small-team-1.png[Разклонена история на John.]

Следва командата за сливане в локалното хранилище:

[source,console]
----
$ git merge origin/master
Merge made by the 'recursive' strategy.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
----

След като това локално сливане мине гладки, обновената история на John ще изглежда така:

.Хранилището на John след сливането на `origin/master`.
image::images/small-team-2.png[Хранилището на John след сливането на `origin/master`.]

В този момент, John може да поиска да провери дали новия код не засяга по някакъв начин неговата работа и след като всичко е нормално, може да я изпрати всичко към сървъра:

[source,console]
----
$ git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -> master
----

В края, изторията на къмитите на John ще изглежда така:

.Историята на John след изпращане към `origin` сървъра.
image::images/small-team-3.png[Историята на John след изпращане към `origin` сървъра.]

Междувременно, Jessica създава нов topic клон наречен `issue54` и прави три къмита в него.
Тя все още не е издърпала промените на John, така че историята ѝ изглежда така:

.Topic клонът на Jessica.
image::images/small-team-4.png[Topic клонът на Jessica.]

Внезапно, Jessica научава, че John е публикувал някакви нови промени и иска да ги погледне, така че може да издърпа от сървъра:

[source,console]
----
# Jessica's Machine
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -> origin/master
----

Това ще изтегли промените на John и историята на Jessica изглежда така:

.Историята на Jessica след изтегляне на промените на John.
image::images/small-team-5.png[Историята на Jessica след изтегляне на промените на John]

Jessica решава, че нейният topic клон вече е готов, но иска да знае коя част от работата на John трябва да слее със своята, така че да може да публикува.
Тя изпълнява за целта командата `git log`:

[source,console]
----
$ git log --no-merges issue54..origin/master
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 16:01:27 2009 -0700

   remove invalid default value
----

Синтаксисът `issue54..origin/master` е филтър, който указва на Git да покаже само тези къмити, които са налични във втория клон (в случая `origin/master`), но липсват в първия (`issue54`).
Ще разгледаме в подробности този синтаксис в <<_commit_ranges>>.

От горния изход можем да видим, че съществува един къмит направен от John, който Jessica не е сляла в локалното си копие.
Ако тя слее `origin/master`, това ще е единственият къмит, който би променил локалната ѝ работа.

Сега тя може да слее своя topic клон в `master` клона си, да слее работата на John (`origin/master`) пак в него и накрая да публуква всички промени към сървъра.

Първо (след като е къмитнала всичко в `issue54` клона), Jessica превключва обратно към `master` клона си:

[source,console]
----
$ git checkout master
Switched to branch 'master'
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
----

Jessica може да слее първо `origin/master` или `issue54` -- и двата са upstream, така че редът е без значение.
Крайният snapshot трябва да е идентичен, само историята ще се различава.
Тя решава да слее първо `issue54` клона:

[source,console]
----
$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)
----

Не възникват проблеми, това е просто fast-forward сливане.
Jessica сега завършва процеса по локално сливане като слива работата на John от клона `orgin/master`:

[source,console]
----
$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by the 'recursive' strategy.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)
----

Всичко се слива чисто и историята на Jessica сега изглежда така:

.Историята на Jessica след сливане на промените от John.
image::images/small-team-6.png[Историята на Jessica след сливане на промените от John.]

Сега `origin/master` е достъпен от `master` клона на Jessica, така че тя може успешно да публикува промените (приемаме, че междувременно John не е изпращал нови такива):

[source,console]
----
$ git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -> master
----

Сега всеки разработчик е къмитнал по няколко пъти и успешно е слял работата на колегата си.

.Историята на Jessica след изпращането на всички промени към сървъра.
image::images/small-team-7.png[Историята на Jessica след изпращането на всички промени към сървъра.]

Това е един от най-простите процеси на работа.

Вие работите известно време (обикновено в topic клон) и сливате работата си в `master` клона, когато е свършена.
Когато желаете да споделите тази работа, вие изтегляте и сливате вашия `master` с `origin/master`, ако той е променен, накрая публикувате `master` клона си в сървъра.
Общата последователност изглежда подобно:

.Обичайна последователност от събития при прост работен процес с няколко разработчици в Git.
image::images/small-team-flow.png[Обичайна последователност от събития при прост работен процес с няколко разработчици в Git.]

==== Работа в управляван екип

(((contributing, private managed team)))
В този сценарий, ще разгледаме как да допринасяме в по-голям частен екип от разработчици.
Ще разберете как да работите в обкръжение, в което малки групи си сътрудничат по определени функционалности, след което резултатът от работата на тези групи се интегрира в проекта от трети човек.

Нека приемем, че John и Jessica работят по функционалността ``feature A'', докато Jessica и друг програмист, Josie, работят по друга опция, ``feature B''.
В този случай, компанията използва работен процес от тип integration-manager, при който работата на индивидуалните групи се интегрира само от определени хора и `master` клонът на главното хранилище може да се обновява само от тези хора.
В сценарий като този, цялата работа се върши в екипни клонове, които интеграторите събира по-късно.

Нека проследим работата на Jessica, защото тя работи по две неща, в паралел с двама рзлични разработчици.
Допускаме, че тя вече има клонирано своето хранилище и решава да започне работа първо по `featureA`.
Тя създава нов клон и работи по него тук:

[source,console]
----
# Jessica's Machine
$ git checkout -b featureA
Switched to a new branch 'featureA'
$ vim lib/simplegit.rb
$ git commit -am 'add limit to log function'
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)
----

В този момент, тя трябва да сподели работата си с John, така че изпраща къмитите от клона `featureA` към сървъра.
Тя обаче няма push достъп до `master` клона -- само интеграторите имат такъв -- ето защо трябва да публикува в друг клон, за да работи съвместно с John:

[source,console]
----
$ git push -u origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -> featureA
----

Jessica изпраща на John съобщение за това, че е изпратила своята работа в клон наречен `feature A` и сега той може да го погледне.
Докато чака за мнението на John, Jessica решава да започне работа по `feature B` с Josie.
За да започне, тя стартира нов feature клон, базирайки го на `master` клона от сървъра:

[source,console]
----
# Jessica's Machine
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch 'featureB'
----

Сега тя прави няколко къмита в клона `featureB`:

[source,console]
----
$ vim lib/simplegit.rb
$ git commit -am 'made the ls-tree function recursive'
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am 'add ls-files'
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)
----

Хранилището на Jessica сега изглежда така:

.Първоначалните къмити на Jessica.
image::images/managed-team-1.png[Първоначалните къмити на Jessica.]

Готова е да изпрати своята работа, но в този момент получава имейл от Josie, в който се съобщава, че на сървъра вече има създаден клон с някаква предварително свършена работа по ``featureB''. Този клон се казва `featureBee`.
Jessica сега трябва първо да слее тези промени със своите собствени преди да може да изпрати към сървъра.
Тя изтегля промените на Josie с `git fetch`:

[source,console]
----
$ git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -> origin/featureBee
----

Приемайки, че локално тя е все още в клона `featureB`, тя може да слее работата на Josie с `git merge`:

[source,console]
----
$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by the 'recursive' strategy.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)
----

В този момент, тя иска да изпрати цялата си слята работа от ``featureB'' обратно към сървъра, но не иска да го направи просто изпращайки своя собствен `featureB` клон
Вместо това, понеже Josie вече е направил upstream `featureBee` клон, Jessica ще иска да изпраща промените си именно към _този_ клон, затова тя прави така:

[source,console]
----
$ git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -> featureBee
----

Това се нарича _refspec_, указване на референция.
Вижте <<_refspec>> за повече детайли относно Git refspecs и различните възможности, които ви се предоставят с тях.
Отбележете също `-u` флага; това е съкращение за `--set-upstream`, който аргумент конфигурира клоновете за лесно дърпане и изпращане.

Внезапно, Jessica получава имейл от John, който ѝ казва, че е публикувал някои промени по `featureA` клона, по който си сътрудничат и моли Jessica да ги погледне.
Отново, Jessica изпълнява `git fetch` за да изтегли _цялото_ ново съдържание от сървъра, включително последните промени на John:

[source,console]
----
$ git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -> origin/featureA
----

Jessica може да покаже историята на промените на John сравнявайки съдържанието на новоизвлечения `featureA` клон с локалното копие на същия такъв:

[source,console]
----
$ git log featureA..origin/featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25
----

Ако Jessica харесва това, което вижда, тя може да слее промените от John в локалния си `featureA` клон:

[source,console]
----
$ git checkout featureA
Switched to branch 'featureA'
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)
----

Накрая, Jessica може да желае да направи няколко малки корекции към цялото това слято съдържание, така че е свободна да ги реализира, да ги къмитне в локалния `featureA` клон, и да публикува финалния резултат на сървъра.

[source,console]
----
$ git commit -am 'small tweak'
[featureA 774b3ed] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
$ git push
...
To jessica@githost:simplegit.git
   3300904..774b3ed  featureA -> featureA
----

Jessica's commit history now looks something like this:
Сега историята на къмитите на Jessica ще изглежда по подобен начин:

.Историята на Jessica след къмитите.
image::images/managed-team-2.png[Историята на Jessica след къмитите.]

В дадне момент, Jessica, Josie, и John информират интеграторите, че `featureA` и `featureBee` клоновете на сървъра са готови за интегриране.
След като интеграторите слеят тези клонове в оосновния проект, едно изтегляне ще предостави новия merge къмит, променяйки историята така:

.Историята на Jessica след сливането на двата ѝ topic клона.
image::images/managed-team-3.png[Историята на Jessica след сливането на двата ѝ topic клона.]

Много екипи преминават към Git поради възможностите за паралелна работа на множество екипи и сливане на различните работни нишки по-късно в процеса.
Възможността малки подгрупи от един екип да работят съвместно чрез отдалечени клонове без да е необходимо да въвличат в това целия екип или да възпрепятстват работата на другите, е огромно преимущество с Git.
Последователността на работния процес, който описахме, би могла да се илюстрира така:

.Последователност на действията в managed-team работен процес.
image::images/managed-team-flow.png[Последователност на действията в managed-team работен процес.]

[[_public_project]]
==== Клониран публичен проект

(((contributing, public small project)))
Допринасянето към публични проекти е малко по-различно.
Понеже нямате права директно да обновявате клоновете на един такъв проект, по някакъв начин трябва да изпратите работата си до хората, които го поддържат.
Този първи пример описва как се сътрудничи чрез клониране на Git хостове, които поддържат easy forking.
Много от публичните хостинг платформи (вкл. GitHub, BitBucket, repo.or.cz, и други), както и много от поддържащите дадени проекти, очакват именно такъв подход за външна помощ.
Следващата секция се занимава с проекти, които предпочитат да приемат предложените пачове чрез имейл.

Първо, вероятно ще искате да клонирате главното хранилище, да създадете topic клон за пача или серията пачове, които планирате да предложите и да работите в него.
Последователността изглежда така:

[source,console]
----
$ git clone <url>
$ cd project
$ git checkout -b featureA
  ... work ...
$ git commit
  ... work ...
$ git commit
----

[NOTE]
====
Може да искате да използвате `rebase -i` за да съберете работата си в единичен къмит, или пък да реорганизирате нещата в множество къмити, така че мениджърът на проекта по-лесно да я разгледа -- вижте <<_rewriting_history>> за повече информация за интерактивното пребазиране.
====

Когато работата ви по клона е завършена и сте готови да я предложите на поддържащите проекта, отидете обратно в неговата страница и използвайте бутона ``Fork'', така че да си направите свое собствено копие от проекта в сайта, с права за писане в него.
След това трябва да добавите URL-а на копието като нова отдалечена референция за локалното ви хранилище, за този пример - нека да я наречем `myfork`:

[source,console]
----
$ git remote add myfork <url>
----

След това трябва да публикувате локалната си работа в това отдалечено хранилище.
Най-лесно е да публикувате topic клона, по който работите, вместо първо са го сливате в master клона и да публикувате него.
Причината за това е, че ако вашата работа не бъде приета или е cherry-picked, няма да има нужда да превъртате обратно вашия master клон (`cherry-pick` операцията на Git се разглежда в повече подробности в <<_rebase_cherry_pick>>).
Ако поддържащите проекта `слеят`, `пребазират`, или `cherry-pick`-нат вашата работа, в крайна сметка ще я получите обратно чрез издърпване от тяхното хранилище.

Във всеки случай, можете да публикувате работата си чрез:

[source,console]
----
$ git push -u myfork featureA
----

(((git commands, request-pull)))
След като работата ви е била публикувана във вашето клонирано онлайн хранилище, ще трябва да уведомите поддържащите оригиналния проект, че имате промени, които бихте искали да интегрират.
Това често се нарича _pull request_ и обикновено такава заявка се генерира или директно през уеб сайта -- GitHub има собствен ``Pull Request'' механизъм, който ще видим в <<_github>> -- или пък с командата `git request-pull` чийто изход трябва да изпратите по имейл на мениджъра на проекта ръчно.

Командата `git request-pull` взема за параметри базовия клон, в който искате промените ви да бъдат интегрирани и адреса на Git хранилището, от което тези промени да бъдат изтеглени, след което изготвя списък с всички промени, които искате да бъдат изтеглени.
Например, ако Jessica иска да изпрати на John pull request и е направила два къмита в topic клона, който току що е публикувала, тя може да изпълни следното:

[source,console]
----
$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
  John Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)
----

Този изход може да се изпрати към поддържащия проекта -- той ще покаже откъде е разклонена работата, обобщава къмитите и указва откъде може да се изтегли новата работа.

В проект, който не поддържате, обикновено е по-лесно да имате клон като `master`, който винаги следи `origin/master ` и да вършите работата си в topic клонове, които лесно можете да премахнете, в случай че бъдат отхвърлени.
Изолирането на работата в topic клонове също така прави по-лесно пребазирането на вашата работа, ако "върха" на главното хранилище се премести междувременно и къмитите ви вече не се прилагат чисто.
Например, ако искате да изпратите втора промяна в проекта, не продължавайте да работите в topic клона, който вече сте изпратили -- започнете от `master` клона на главното хранилище:

[source,console]
----
$ git checkout -b featureB origin/master
  ... work ...
$ git commit
$ git push myfork featureB
$ git request-pull origin/master myfork
  ... email generated request pull to maintainer ...
$ git fetch origin
----

Сега, всяка от промените ви се съдържа в силоз -- подобно на опашка от пачове -- които можете да пренапишете, пребазирате и променяте без различните теми да се преплитат или да зависят една от друга:

.Първоначална история на къмитите с `featureB`.
image::images/public-small-1.png[Първоначална история на къмитите с `featureB`.]

Да кажем, че мениджърът на проекта е интегрирал множество други пачове и е опитал вашия първи клон, който обаче вече не се слива чисто.
В този случай, можете да пробвате да пребазирате този клон върху `origin/master`, да оправите конфликтите и да изпратите повторно промените си:

[source,console]
----
$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA
----

Това ще промени историята ви така <<psp_b>>.

[[psp_b]]
.Commit history after `featureA` work.
image::images/public-small-2.png[Commit history after `featureA` work.]

Because you rebased the branch, you have to specify the `-f` to your push command in order to be able to replace the `featureA` branch on the server with a commit that isn't a descendant of it.
An alternative would be to push this new work to a different branch on the server (perhaps called `featureAv2`).

Let's look at one more possible scenario: the maintainer has looked at work in your second branch and likes the concept but would like you to change an implementation detail.
You'll also take this opportunity to move the work to be based off the project's current `master` branch.
You start a new branch based off the current `origin/master` branch, squash the `featureB` changes there, resolve any conflicts, make the implementation change, and then push that as a new branch:

(((git commands, merge, squash)))
[source,console]
----
$ git checkout -b featureBv2 origin/master
$ git merge --squash featureB
  ... change implementation ...
$ git commit
$ git push myfork featureBv2
----

The `--squash` option takes all the work on the merged branch and squashes it into one changeset producing the repository state as if a real merge happened, without actually making a merge commit.
This means your future commit will have one parent only and allows you to introduce all the changes from another branch and then make more changes before recording the new commit.
Also the `--no-commit` option can be useful to delay the merge commit in case of the default merge process.

At this point, you can notify the maintainer that you've made the requested changes, and that they can find those changes in your `featureBv2` branch.

.Commit history after `featureBv2` work.
image::images/public-small-3.png[Commit history after `featureBv2` work.]

[[_project_over_email]]
==== Public Project over Email

(((contributing, public large project)))
Many projects have established procedures for accepting patches -- you'll need to check the specific rules for each project, because they will differ.
Since there are several older, larger projects which accept patches via a developer mailing list, we'll go over an example of that now.

The workflow is similar to the previous use case -- you create topic branches for each patch series you work on.
The difference is how you submit them to the project.
Instead of forking the project and pushing to your own writable version, you generate email versions of each commit series and email them to the developer mailing list:

[source,console]
----
$ git checkout -b topicA
  ... work ...
$ git commit
  ... work ...
$ git commit
----

(((git commands, format-patch)))
Now you have two commits that you want to send to the mailing list.
You use `git format-patch` to generate the mbox-formatted files that you can email to the list -- it turns each commit into an email message with the first line of the commit message as the subject and the rest of the message plus the patch that the commit introduces as the body.
The nice thing about this is that applying a patch from an email generated with `format-patch` preserves all the commit information properly.

[source,console]
----
$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
----

The `format-patch` command prints out the names of the patch files it creates.
The `-M` switch tells Git to look for renames.
The files end up looking like this:

[source,console]
----
$ cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log #{treeish}")
+    command("git log -n 20 #{treeish}")
   end

   def ls_tree(treeish = 'master')
--
2.1.0
----

You can also edit these patch files to add more information for the email list that you don't want to show up in the commit message.
If you add text between the `---` line and the beginning of the patch (the `diff --git` line), the developers can read it, but that content is ignored by the patching process.

To email this to a mailing list, you can either paste the file into your email program or send it via a command-line program.
Pasting the text often causes formatting issues, especially with ``smarter'' clients that don't preserve newlines and other whitespace appropriately.
Luckily, Git provides a tool to help you send properly formatted patches via IMAP, which may be easier for you.
We'll demonstrate how to send a patch via Gmail, which happens to be the email agent we know best; you can read detailed instructions for a number of mail programs at the end of the aforementioned `Documentation/SubmittingPatches` file in the Git source code.

(((git commands, config)))(((email)))
First, you need to set up the imap section in your `~/.gitconfig` file.
You can set each value separately with a series of `git config` commands, or you can add them manually, but in the end your config file should look something like this:

[source,ini]
----
[imap]
  folder = "[Gmail]/Drafts"
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = YX]8g76G_2^sFbd
  port = 993
  sslverify = false
----

If your IMAP server doesn't use SSL, the last two lines probably aren't necessary, and the host value will be `imap://` instead of `imaps://`.
When that is set up, you can use `git imap-send` to place the patch series in the Drafts folder of the specified IMAP server:

[source,console]
----
$ cat *.patch |git imap-send
Resolving imap.gmail.com... ok
Connecting to [74.125.142.109]:993... ok
Logging in...
sending 2 messages
100% (2/2) done
----

At this point, you should be able to go to your Drafts folder, change the To field to the mailing list you're sending the patch to, possibly CC the maintainer or person responsible for that section, and send it off.

You can also send the patches through an SMTP server.
As before, you can set each value separately with a series of `git config` commands, or you can add them manually in the sendemail section in your `~/.gitconfig` file:

[source,ini]
----
[sendemail]
  smtpencryption = tls
  smtpserver = smtp.gmail.com
  smtpuser = user@gmail.com
  smtpserverport = 587
----

After this is done, you can use `git send-email` to send your patches:

[source,console]
----
$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith <jessica@example.com>]
Emails will be sent from: Jessica Smith <jessica@example.com>
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y
----

Then, Git spits out a bunch of log information looking something like this for each patch you're sending:

[source,text]
----
(mbox) Adding cc: Jessica Smith <jessica@example.com> from
  \line 'From: Jessica Smith <jessica@example.com>'
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith <jessica@example.com>
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: <1243715356-61726-1-git-send-email-jessica@example.com>
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: <y>
References: <y>

Result: OK
----

==== Summary

This section has covered a number of common workflows for dealing with several very different types of Git projects you're likely to encounter, and introduced a couple of new tools to help you manage this process.
Next, you'll see how to work the other side of the coin: maintaining a Git project.
You'll learn how to be a benevolent dictator or integration manager.
